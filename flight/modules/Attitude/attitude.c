/**
 ******************************************************************************
 * @addtogroup OpenPilotModules OpenPilot Modules
 * @{
 * @addtogroup Attitude Copter Control Attitude Estimation
 * @brief Acquires sensor data and computes attitude estimate
 * Specifically updates the the @ref AttitudeState "AttitudeState" and @ref AttitudeRaw "AttitudeRaw" settings objects
 * @{
 *
 * @file       attitude.c
 * @author     The OpenPilot Team, http://www.openpilot.org Copyright (C) 2010.
 * @brief      Module to handle all comms to the AHRS on a periodic basis.
 *
 * @see        The GNU Public License (GPL) Version 3
 *
 ******************************************************************************/
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

/**
 * Input objects: None, takes sensor data via pios
 * Output objects: @ref AttitudeRaw @ref AttitudeState
 *
 * This module computes an attitude estimate from the sensor data
 *
 * The module executes in its own thread.
 *
 * UAVObjects are automatically generated by the UAVObjectGenerator from
 * the object definition XML file.
 *
 * Modules have no API, all communication to other modules is done through UAVObjects.
 * However modules may use the API exposed by shared libraries.
 * See the OpenPilot wiki for more details.
 * http://www.openpilot.org/OpenPilot_Application_Architecture
 *
 */

#include <openpilot.h>

#include <pios_board_info.h>

#include "attitude.h"
#include "gyrostate.h"
#include "accelstate.h"
#include "attitudestate.h"
#include "attitudesettings.h"
#include "flightstatus.h"
#include "manualcontrolcommand.h"
#include "taskinfo.h"

#include "CoordinateConversions.h"


// Private constants
#define STACK_SIZE_BYTES 540
#define TASK_PRIORITY    (tskIDLE_PRIORITY + 4)

#define SENSOR_PERIOD    4
#define UPDATE_RATE      25.0f
#define GYRO_NEUTRAL     1665

// Private types

// Private variables
static xTaskHandle taskHandle;

// Private functions
static void AttitudeTask(void *parameters);

static float gyro_correct_int[3] = { 0, 0, 0 };
#if defined(PIOS_INCLUDE_ADXL345)
static xQueueHandle gyro_queue;
#endif

static int32_t updateSensors(AccelStateData *, GyroStateData *);
static int32_t updateSensorsCC3D(AccelStateData *accelStateData, GyroStateData *gyrosData);
static void updateAttitude(AccelStateData *, GyroStateData *);
static void settingsUpdatedCb(UAVObjEvent *objEv);

static float accelKi     = 0;
static float accelKp     = 0;
static float accel_alpha = 0;
static bool accel_filter_enabled = false;
static float accels_filtered[3];
static float grot_filtered[3];
static float yawBiasRate = 0;
static float rollPitchBiasRate = 0.0f;
static float gyroGain    = 0.42f;
static int16_t accelbias[3];
static float q[4] = { 1, 0, 0, 0 };
static float R[3][3];
static int8_t rotate = 0;
static bool zero_during_arming = false;
static bool bias_correct_gyro  = true;

// For running trim flights
static volatile bool trim_requested   = false;
static volatile int32_t trim_accels[3];
static volatile int32_t trim_samples;
int32_t const MAX_TRIM_FLIGHT_SAMPLES = 65535;

#define GRAV        9.81f
#define ACCEL_SCALE (GRAV * 0.004f)
/* 0.004f is gravity / LSB */

/**
 * Initialise the module, called on startup
 * \returns 0 on success or -1 if initialisation failed
 */
int32_t AttitudeStart(void)
{
    // Start main task
    xTaskCreate(AttitudeTask, (signed char *)"Attitude", STACK_SIZE_BYTES / 4, NULL, TASK_PRIORITY, &taskHandle);
    PIOS_TASK_MONITOR_RegisterTask(TASKINFO_RUNNING_ATTITUDE, taskHandle);
#ifdef PIOS_INCLUDE_WDG
    PIOS_WDG_RegisterFlag(PIOS_WDG_ATTITUDE);
#endif

    return 0;
}

/**
 * Initialise the module, called on startup
 * \returns 0 on success or -1 if initialisation failed
 */
int32_t AttitudeInitialize(void)
{
    AttitudeStateInitialize();
    AttitudeSettingsInitialize();
    AccelStateInitialize();
    GyroStateInitialize();

    // Initialize quaternion
    AttitudeStateData attitude;
    AttitudeStateGet(&attitude);
    attitude.q1 = 1;
    attitude.q2 = 0;
    attitude.q3 = 0;
    attitude.q4 = 0;
    AttitudeStateSet(&attitude);

    // Cannot trust the values to init right above if BL runs
    gyro_correct_int[0] = 0;
    gyro_correct_int[1] = 0;
    gyro_correct_int[2] = 0;

    q[0] = 1;
    q[1] = 0;
    q[2] = 0;
    q[3] = 0;
    for (uint8_t i = 0; i < 3; i++) {
        for (uint8_t j = 0; j < 3; j++) {
            R[i][j] = 0;
        }
    }

    trim_requested = false;

    AttitudeSettingsConnectCallback(&settingsUpdatedCb);

    return 0;
}

MODULE_INITCALL(AttitudeInitialize, AttitudeStart);

/**
 * Module thread, should not return.
 */

int32_t accel_test;
int32_t gyro_test;
static void AttitudeTask(__attribute__((unused)) void *parameters)
{
    uint8_t init = 0;

    AlarmsClear(SYSTEMALARMS_ALARM_ATTITUDE);

    // Set critical error and wait until the accel is producing data
#if defined(PIOS_INCLUDE_ADXL345)
    while (PIOS_ADXL345_FifoElements() == 0) {
        AlarmsSet(SYSTEMALARMS_ALARM_ATTITUDE, SYSTEMALARMS_ALARM_CRITICAL);
#ifdef PIOS_INCLUDE_WDG
        PIOS_WDG_UpdateFlag(PIOS_WDG_ATTITUDE);
#endif
    }
#endif

    const struct pios_board_info *bdinfo = &pios_board_info_blob;

    bool cc   = bdinfo->board_type == 0x04;
    bool cc3d = cc && ((bdinfo->board_rev == 0x02) || (bdinfo->board_rev == 0x03));

    if (cc3d) {
#if defined(PIOS_INCLUDE_MPU6000)
        PIOS_Assert(PIOS_MPU6000_Test() == 0);
#endif
    } else {
#if defined(PIOS_INCLUDE_ADXL345)
        accel_test = PIOS_ADXL345_Test();
#if defined(PIOS_INCLUDE_ADC)
        // Create queue for passing gyro data, allow 2 back samples in case
        gyro_queue = xQueueCreate(1, sizeof(float) * 4);
        PIOS_Assert(gyro_queue != NULL);
        PIOS_ADC_SetQueue(gyro_queue);
        PIOS_ADC_Config((PIOS_ADC_RATE / 1000.0f) * UPDATE_RATE);
#endif
#endif
    }
    // Force settings update to make sure rotation loaded
    settingsUpdatedCb(AttitudeSettingsHandle());

    // Main task loop
    while (1) {
        FlightStatusData flightStatus;
        FlightStatusGet(&flightStatus);

        if ((xTaskGetTickCount() < 7000) && (xTaskGetTickCount() > 1000)) {
            // Use accels to initialise attitude and calculate gyro bias
            accelKp     = 1.0f;
            accelKi     = 0.0f;
            yawBiasRate = 0.01f;
            rollPitchBiasRate    = 0.01f;
            accel_filter_enabled = false;
            init = 0;
        } else if (zero_during_arming && (flightStatus.Armed == FLIGHTSTATUS_ARMED_ARMING)) {
            accelKp     = 1.0f;
            accelKi     = 0.0f;
            yawBiasRate = 0.01f;
            rollPitchBiasRate    = 0.01f;
            accel_filter_enabled = false;
            init = 0;
        } else if (init == 0) {
            // Reload settings (all the rates)
            AttitudeSettingsAccelKiGet(&accelKi);
            AttitudeSettingsAccelKpGet(&accelKp);
            AttitudeSettingsYawBiasRateGet(&yawBiasRate);
            rollPitchBiasRate = 0.0f;
            if (accel_alpha > 0.0f) {
                accel_filter_enabled = true;
            }
            init = 1;
        }

#ifdef PIOS_INCLUDE_WDG
        PIOS_WDG_UpdateFlag(PIOS_WDG_ATTITUDE);
#endif

        AccelStateData accelState;
        GyroStateData gyros;
        int32_t retval = 0;

        if (cc3d) {
            retval = updateSensorsCC3D(&accelState, &gyros);
        } else {
            retval = updateSensors(&accelState, &gyros);
        }

        // Only update attitude when sensor data is good
        if (retval != 0) {
            AlarmsSet(SYSTEMALARMS_ALARM_ATTITUDE, SYSTEMALARMS_ALARM_ERROR);
        } else {
            // Do not update attitude data in simulation mode
            if (!AttitudeStateReadOnly()) {
                updateAttitude(&accelState, &gyros);
            }

            AlarmsClear(SYSTEMALARMS_ALARM_ATTITUDE);
        }
    }
}

float gyros_passed[3];

/**
 * Get an update from the sensors
 * @param[in] attitudeRaw Populate the UAVO instead of saving right here
 * @return 0 if successfull, -1 if not
 */
static int32_t updateSensors(__attribute__((unused)) AccelStateData *accelState, __attribute__((unused)) GyroStateData *gyros)
{
#if defined(PIOS_INCLUDE_ADXL345)
    struct pios_adxl345_data accel_data;
    float gyro[4];

    // Only wait the time for two nominal updates before setting an alarm
    if (xQueueReceive(gyro_queue, (void *const)gyro, UPDATE_RATE * 2) == errQUEUE_EMPTY) {
        AlarmsSet(SYSTEMALARMS_ALARM_ATTITUDE, SYSTEMALARMS_ALARM_ERROR);
        return -1;
    }

    // Do not read raw sensor data in simulation mode
    if (GyroStateReadOnly() || AccelStateReadOnly()) {
        return 0;
    }

    // No accel data available
    if (PIOS_ADXL345_FifoElements() == 0) {
        return -1;
    }

    // First sample is temperature
    gyros->x = -(gyro[1] - GYRO_NEUTRAL) * gyroGain;
    gyros->y = (gyro[2] - GYRO_NEUTRAL) * gyroGain;
    gyros->z = -(gyro[3] - GYRO_NEUTRAL) * gyroGain;

    int32_t x = 0;
    int32_t y = 0;
    int32_t z = 0;
    uint8_t i = 0;
    uint8_t samples_remaining;
    do {
        i++;
        samples_remaining = PIOS_ADXL345_Read(&accel_data);
        x += accel_data.x;
        y += -accel_data.y;
        z += -accel_data.z;
    } while ((i < 32) && (samples_remaining > 0));
    // gyros->temperature = samples_remaining;

    float accel[3] = { (float)x / i, (float)y / i, (float)z / i };

    if (rotate) {
        // TODO: rotate sensors too so stabilization is well behaved
        float vec_out[3];
        rot_mult(R, accel, vec_out);
        accelState->x = vec_out[0];
        accelState->y = vec_out[1];
        accelState->z = vec_out[2];
        rot_mult(R, &gyros->x, vec_out);
        gyros->x = vec_out[0];
        gyros->y = vec_out[1];
        gyros->z = vec_out[2];
    } else {
        accelState->x = accel[0];
        accelState->y = accel[1];
        accelState->z = accel[2];
    }

    if (trim_requested) {
        if (trim_samples >= MAX_TRIM_FLIGHT_SAMPLES) {
            trim_requested = false;
        } else {
            uint8_t armed;
            float throttle;
            FlightStatusArmedGet(&armed);
            ManualControlCommandThrottleGet(&throttle); // Until flight status indicates airborne
            if ((armed == FLIGHTSTATUS_ARMED_ARMED) && (throttle > 0.0f)) {
                trim_samples++;
                // Store the digitally scaled version since that is what we use for bias
                trim_accels[0] += accelState->x;
                trim_accels[1] += accelState->y;
                trim_accels[2] += accelState->z;
            }
        }
    }

    // Scale accels and correct bias
    accelState->x = (accelState->x - accelbias[0]) * ACCEL_SCALE;
    accelState->y = (accelState->y - accelbias[1]) * ACCEL_SCALE;
    accelState->z = (accelState->z - accelbias[2]) * ACCEL_SCALE;

    if (bias_correct_gyro) {
        // Applying integral component here so it can be seen on the gyros and correct bias
        gyros->x += gyro_correct_int[0];
        gyros->y += gyro_correct_int[1];
        gyros->z += gyro_correct_int[2];
    }

    // Force the roll & pitch gyro rates to average to zero during initialisation
    gyro_correct_int[0] += -gyros->x * rollPitchBiasRate;
    gyro_correct_int[1] += -gyros->y * rollPitchBiasRate;

    // Because most crafts wont get enough information from gravity to zero yaw gyro, we try
    // and make it average zero (weakly)
    gyro_correct_int[2] += -gyros->z * yawBiasRate;

    GyroStateSet(gyros);
    AccelStateSet(accelState);
#endif /* if defined(PIOS_INCLUDE_ADXL345) */

    return 0;
}

/**
 * Get an update from the sensors
 * @param[in] attitudeRaw Populate the UAVO instead of saving right here
 * @return 0 if successfull, -1 if not
 */
struct pios_mpu6000_data mpu6000_data;
static int32_t updateSensorsCC3D(AccelStateData *accelStateData, GyroStateData *gyrosData)
{
    float accels[3], gyros[3];
    uint8_t count = 0;

#if defined(PIOS_INCLUDE_MPU6000)
    // Do not read raw sensor data in simulation mode
    if (GyroStateReadOnly() || AccelStateReadOnly()) {
        return 0;
    }

    // Wait for a signal that there is data ready in the FIFO.
    xSemaphoreHandle semaphore = PIOS_MPU6000_GetSemaphore();
    if (xSemaphoreTake(semaphore, SENSOR_PERIOD) == pdFALSE) {
        return -1;
    }

    // Read all available data out of the FIFO.
    while (PIOS_MPU6000_ReadFifo(&mpu6000_data)) {
        gyros[0]  += mpu6000_data.gyro_x;
        gyros[1]  += mpu6000_data.gyro_y;
        gyros[2]  += mpu6000_data.gyro_z;

        accels[0] += mpu6000_data.accel_x;
        accels[1] += mpu6000_data.accel_y;
        accels[2] += mpu6000_data.accel_z;

        ++count;
    }

    if (count == 0) {
        return -1; // Error, no data
    }

    float gyro_scaling  = PIOS_MPU6000_GetScale() / count;
    float accel_scaling = PIOS_MPU6000_GetAccelScale() / count;

    gyros[0]  *= gyro_scaling;
    gyros[1]  *= gyro_scaling;
    gyros[2]  *= gyro_scaling;

    accels[0] *= accel_scaling;
    accels[1] *= accel_scaling;
    accels[2] *= accel_scaling;

    // gyrosData->temperature  = 35.0f + ((float)mpu6000_data.temperature + 512.0f) / 340.0f;
    // accelsData->temperature = 35.0f + ((float)mpu6000_data.temperature + 512.0f) / 340.0f;
#endif /* if defined(PIOS_INCLUDE_MPU6000) */

    if (rotate) {
        // TODO: rotate sensors too so stabilization is well behaved
        float vec_out[3];
        rot_mult(R, accels, vec_out);
        accels[0] = vec_out[0];
        accels[1] = vec_out[1];
        accels[2] = vec_out[2];
        rot_mult(R, gyros, vec_out);
        gyros[0]  = vec_out[0];
        gyros[1]  = vec_out[1];
        gyros[2]  = vec_out[2];
    }

    accelStateData->x = accels[0] - accelbias[0] * ACCEL_SCALE; // Applying arbitrary scale here to match CC v1
    accelStateData->y = accels[1] - accelbias[1] * ACCEL_SCALE;
    accelStateData->z = accels[2] - accelbias[2] * ACCEL_SCALE;

    gyrosData->x = gyros[0];
    gyrosData->y = gyros[1];
    gyrosData->z = gyros[2];

    if (bias_correct_gyro) {
        // Applying integral component here so it can be seen on the gyros and correct bias
        gyrosData->x += gyro_correct_int[0];
        gyrosData->y += gyro_correct_int[1];
        gyrosData->z += gyro_correct_int[2];
    }

    // Force the roll & pitch gyro rates to average to zero during initialisation
    gyro_correct_int[0] += -gyrosData->x * rollPitchBiasRate;
    gyro_correct_int[1] += -gyrosData->y * rollPitchBiasRate;

    // Because most crafts wont get enough information from gravity to zero yaw gyro, we try
    // and make it average zero (weakly)
    gyro_correct_int[2] += -gyrosData->z * yawBiasRate;

    GyroStateSet(gyrosData);
    AccelStateSet(accelStateData);

    return 0;
}

static inline void apply_accel_filter(const float *raw, float *filtered)
{
    if (accel_filter_enabled) {
        filtered[0] = filtered[0] * accel_alpha + raw[0] * (1 - accel_alpha);
        filtered[1] = filtered[1] * accel_alpha + raw[1] * (1 - accel_alpha);
        filtered[2] = filtered[2] * accel_alpha + raw[2] * (1 - accel_alpha);
    } else {
        filtered[0] = raw[0];
        filtered[1] = raw[1];
        filtered[2] = raw[2];
    }
}

static void updateAttitude(AccelStateData *accelStateData, GyroStateData *gyrosData)
{
    float dT;
    portTickType thisSysTime = xTaskGetTickCount();
    static portTickType lastSysTime = 0;

    dT = (thisSysTime == lastSysTime) ? 0.001f : (thisSysTime - lastSysTime) * portTICK_RATE_MS * 0.001f;
    lastSysTime = thisSysTime;

    // Bad practice to assume structure order, but saves memory
    float *gyros  = &gyrosData->x;
    float *accels = &accelStateData->x;

    float grot[3];
    float accel_err[3];

    // Apply smoothing to accel values, to reduce vibration noise before main calculations.
    apply_accel_filter(accels, accels_filtered);

    // Rotate gravity unit vector to body frame, filter and cross with accels
    grot[0] = -(2 * (q[1] * q[3] - q[0] * q[2]));
    grot[1] = -(2 * (q[2] * q[3] + q[0] * q[1]));
    grot[2] = -(q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3]);

    apply_accel_filter(grot, grot_filtered);

    CrossProduct((const float *)accels_filtered, (const float *)grot_filtered, accel_err);

    // Account for accel magnitude
    float accel_mag = sqrtf(accels_filtered[0] * accels_filtered[0] + accels_filtered[1] * accels_filtered[1] + accels_filtered[2] * accels_filtered[2]);
    if (accel_mag < 1.0e-3f) {
        return;
    }

    // Account for filtered gravity vector magnitude
    float grot_mag;

    if (accel_filter_enabled) {
        grot_mag = sqrtf(grot_filtered[0] * grot_filtered[0] + grot_filtered[1] * grot_filtered[1] + grot_filtered[2] * grot_filtered[2]);
    } else {
        grot_mag = 1.0f;
    }

    if (grot_mag < 1.0e-3f) {
        return;
    }

    accel_err[0] /= (accel_mag * grot_mag);
    accel_err[1] /= (accel_mag * grot_mag);
    accel_err[2] /= (accel_mag * grot_mag);

    // Accumulate integral of error.  Scale here so that units are (deg/s) but Ki has units of s
    gyro_correct_int[0] += accel_err[0] * accelKi;
    gyro_correct_int[1] += accel_err[1] * accelKi;

    // gyro_correct_int[2] += accel_err[2] * accelKi;

    // Correct rates based on error, integral component dealt with in updateSensors
    gyros[0] += accel_err[0] * accelKp / dT;
    gyros[1] += accel_err[1] * accelKp / dT;
    gyros[2] += accel_err[2] * accelKp / dT;

    { // scoping variables to save memory
      // Work out time derivative from INSAlgo writeup
      // Also accounts for the fact that gyros are in deg/s
        float qdot[4];
        qdot[0] = (-q[1] * gyros[0] - q[2] * gyros[1] - q[3] * gyros[2]) * dT * (M_PI_F / 180.0f / 2.0f);
        qdot[1] = (q[0] * gyros[0] - q[3] * gyros[1] + q[2] * gyros[2]) * dT * (M_PI_F / 180.0f / 2.0f);
        qdot[2] = (q[3] * gyros[0] + q[0] * gyros[1] - q[1] * gyros[2]) * dT * (M_PI_F / 180.0f / 2.0f);
        qdot[3] = (-q[2] * gyros[0] + q[1] * gyros[1] + q[0] * gyros[2]) * dT * (M_PI_F / 180.0f / 2.0f);

        // Take a time step
        q[0]    = q[0] + qdot[0];
        q[1]    = q[1] + qdot[1];
        q[2]    = q[2] + qdot[2];
        q[3]    = q[3] + qdot[3];

        if (q[0] < 0) {
            q[0] = -q[0];
            q[1] = -q[1];
            q[2] = -q[2];
            q[3] = -q[3];
        }
    }

    // Renomalize
    float qmag = sqrtf(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);

    // If quaternion has become inappropriately short or is nan reinit.
    // THIS SHOULD NEVER ACTUALLY HAPPEN
    if ((fabsf(qmag) < 1e-3f) || isnan(qmag)) {
        q[0] = 1;
        q[1] = 0;
        q[2] = 0;
        q[3] = 0;
    } else {
        q[0] = q[0] / qmag;
        q[1] = q[1] / qmag;
        q[2] = q[2] / qmag;
        q[3] = q[3] / qmag;
    }

    AttitudeStateData attitudeState;
    AttitudeStateGet(&attitudeState);

    quat_copy(q, &attitudeState.q1);

    // Convert into eueler degrees (makes assumptions about RPY order)
    Quaternion2RPY(&attitudeState.q1, &attitudeState.Roll);

    AttitudeStateSet(&attitudeState);
}

static void settingsUpdatedCb(__attribute__((unused)) UAVObjEvent *objEv)
{
    AttitudeSettingsData attitudeSettings;

    AttitudeSettingsGet(&attitudeSettings);


    accelKp     = attitudeSettings.AccelKp;
    accelKi     = attitudeSettings.AccelKi;
    yawBiasRate = attitudeSettings.YawBiasRate;
    gyroGain    = attitudeSettings.GyroGain;

    // Calculate accel filter alpha, in the same way as for gyro data in stabilization module.
    const float fakeDt = 0.0025f;
    if (attitudeSettings.AccelTau < 0.0001f) {
        accel_alpha = 0; // not trusting this to resolve to 0
        accel_filter_enabled = false;
    } else {
        accel_alpha = expf(-fakeDt / attitudeSettings.AccelTau);
        accel_filter_enabled = true;
    }

    zero_during_arming = attitudeSettings.ZeroDuringArming == ATTITUDESETTINGS_ZERODURINGARMING_TRUE;
    bias_correct_gyro  = attitudeSettings.BiasCorrectGyro == ATTITUDESETTINGS_BIASCORRECTGYRO_TRUE;

    accelbias[0] = attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_X];
    accelbias[1] = attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_Y];
    accelbias[2] = attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_Z];

    gyro_correct_int[0] = attitudeSettings.GyroBias[ATTITUDESETTINGS_GYROBIAS_X] / 100.0f;
    gyro_correct_int[1] = attitudeSettings.GyroBias[ATTITUDESETTINGS_GYROBIAS_Y] / 100.0f;
    gyro_correct_int[2] = attitudeSettings.GyroBias[ATTITUDESETTINGS_GYROBIAS_Z] / 100.0f;

    // Indicates not to expend cycles on rotation
    if (attitudeSettings.BoardRotation[0] == 0 && attitudeSettings.BoardRotation[1] == 0 &&
        attitudeSettings.BoardRotation[2] == 0) {
        rotate = 0;

        // Shouldn't be used but to be safe
        float rotationQuat[4] = { 1, 0, 0, 0 };
        Quaternion2R(rotationQuat, R);
    } else {
        float rotationQuat[4];
        const float rpy[3] = { attitudeSettings.BoardRotation[ATTITUDESETTINGS_BOARDROTATION_ROLL],
                               attitudeSettings.BoardRotation[ATTITUDESETTINGS_BOARDROTATION_PITCH],
                               attitudeSettings.BoardRotation[ATTITUDESETTINGS_BOARDROTATION_YAW] };
        RPY2Quaternion(rpy, rotationQuat);
        Quaternion2R(rotationQuat, R);
        rotate = 1;
    }

    if (attitudeSettings.TrimFlight == ATTITUDESETTINGS_TRIMFLIGHT_START) {
        trim_accels[0] = 0;
        trim_accels[1] = 0;
        trim_accels[2] = 0;
        trim_samples   = 0;
        trim_requested = true;
    } else if (attitudeSettings.TrimFlight == ATTITUDESETTINGS_TRIMFLIGHT_LOAD) {
        trim_requested = false;
        attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_X] = trim_accels[0] / trim_samples;
        attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_Y] = trim_accels[1] / trim_samples;
        // Z should average -grav
        attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_Z] = trim_accels[2] / trim_samples + GRAV / ACCEL_SCALE;
        attitudeSettings.TrimFlight = ATTITUDESETTINGS_TRIMFLIGHT_NORMAL;
        AttitudeSettingsSet(&attitudeSettings);
    } else {
        trim_requested = false;
    }
}
/**
 * @}
 * @}
 */
