/* -*- Mode: c; c-basic-offset: 2; tab-width: 2; indent-tabs-mode: t -*- */
/**
******************************************************************************
* @addtogroup OpenPilotModules OpenPilot Modules
* @{
* @addtogroup TransmitterControls Copter Control TransmitterControls Estimation
* @brief Acquires sensor data and computes attitude estimate
* Specifically updates the the @ref TransmitterControlsActual "TransmitterControlsActual" and @ref TransmitterControlsRaw "TransmitterControlsRaw" settings objects
* @{
*
* @file				radio.c
* @author			The OpenPilot Team, http://www.openpilot.org Copyright (C) 2010.
* @brief			Module to handle all comms to the AHRS on a periodic basis.
*
* @see				The GNU Public License (GPL) Version 3
*
******************************************************************************/
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

/**
 * Input objects: None, takes sensor data via pios
 * Output objects: @ref TransmitterControlsRaw @ref TransmitterControlsActual
 *
 * This module computes an attitude estimate from the sensor data
 *
 * The module executes in its own thread.
 *
 * UAVObjects are automatically generated by the UAVObjectGenerator from
 * the object definition XML file.
 *
 * Modules have no API, all communication to other modules is done through UAVObjects.
 * However modules may use the API exposed by shared libraries.
 * See the OpenPilot wiki for more details.
 * http://www.openpilot.org/OpenPilot_Application_Architecture
 *
 */

#include "pios.h"
#include "manualcontrolcommand.h"
#include "transmittercontrols.h"

// Private constants
//#define STACK_SIZE_BYTES 540
#define STACK_SIZE_BYTES 320
#define TASK_PRIORITY (tskIDLE_PRIORITY+3)

#define UPDATE_RATE	 2.0f

#define REQ_TIMEOUT_MS 250
#define MAX_RETRIES 2

// Private types

// Private variables
static xTaskHandle taskHandle;
//static xTaskHandle txTaskHandle;
//static xTaskHandle rxTaskHandle;
//static uint32_t telemetryPort;
static xQueueHandle adc_queue;
static xQueueHandle txqueue;
//static UAVTalk com;
//static uint32_t txErrors;
//static uint32_t txRetries;

// Private functions
static void transmitterControlsTask(void *parameters);
//static void transmitterTxTask(void *parameters);
//static void transmitterRxTask(void *parameters);
//static void processObjEvent(UAVObjEvent * ev);
//static int32_t transmitData(uint8_t * data, int32_t length);
static void registerObject(UAVObjHandle obj);
static void updateObject(UAVObjHandle obj);
static int32_t setUpdatePeriod(UAVObjHandle obj, int32_t updatePeriodMs);


/**
 * Initialise the module, called on startup
 * \returns 0 on success or -1 if initialisation failed
 */
int32_t TransmitterControlsStart(void) {

	// Start main task
	xTaskCreate(transmitterControlsTask, (signed char *)"TransmitterControls", STACK_SIZE_BYTES/4, NULL, TASK_PRIORITY, &taskHandle);
	//TaskMonitorAdd(TASKINFO_RUNNING_TRANSMITTERCONTROLS, taskHandle);
	PIOS_WDG_RegisterFlag(PIOS_WDG_ATTITUDE);

#ifdef NVER
	// Start the Tx and Rx tasks
	xTaskCreate(transmitterTxTask, (signed char *)"TransmitterTx", STACK_SIZE_BYTES/4, NULL, TASK_PRIORITY, &txTaskHandle);
	//TaskMonitorAdd(TASKINFO_RUNNING_TRANSMITTERTX, txTaskHandle);
	xTaskCreate(transmitterRxTask, (signed char *)"TransmitterRx", STACK_SIZE_BYTES/4, NULL, TASK_PRIORITY, &rxTaskHandle);
	//TaskMonitorAdd(TASKINFO_RUNNING_TRANSMITTERRX, rxTaskHandle);
	}
#endif

	return 0;
}

/**
 * Initialise the module, called on startup
 * \returns 0 on success or -1 if initialisation failed
 */
int32_t TransmitterControlsInitialize(void) {

	// Create queue for passing control data, allow 2 back samples in case
	adc_queue = xQueueCreate(1, sizeof(float) * 4);
	if(adc_queue == NULL)
		return -1;
	PIOS_ADC_SetQueue(adc_queue);

	// Create object queues
	txqueue = xQueueCreate(TELEM_QUEUE_SIZE, sizeof(UAVObjEvent));

	// Initialise UAVTalk
	//UAVTalkInitialize(&com, &transmitData);

	// Process all registered objects and connect queue for updates
	UAVObjIterate(&registerObject);

	//TransmitterControlsSettingsConnectCallback(&settingsUpdatedCb);

	return 0;
}

MODULE_INITCALL(TransmitterControlsInitialize, TransmitterControlsStart)

/**
 * Set update period of object (it must be already setup for periodic updates)
 * \param[in] obj The object to update
 * \param[in] updatePeriodMs The update period in ms, if zero then periodic updates are disabled
 * \return 0 Success
 * \return -1 Failure
 */
static int32_t setUpdatePeriod(UAVObjHandle obj, int32_t updatePeriodMs)
{
	UAVObjEvent ev;

	// Add object for periodic updates
	ev.obj = obj;
	ev.instId = UAVOBJ_ALL_INSTANCES;
	ev.event = EV_UPDATED_MANUAL;
	return EventPeriodicQueueUpdate(&ev, txqueue, updatePeriodMs);
}

/**
 * Update object's queue connections and timer, depending on object's settings
 * \param[in] obj Object to updates
 */
static void updateObject(UAVObjHandle obj)
{
	UAVObjMetadata metadata;
	int32_t eventMask;

	// Get metadata
	UAVObjGetMetadata(obj, &metadata);

	// Setup object depending on update mode
	if (metadata.telemetryUpdateMode == UPDATEMODE_PERIODIC) {
		// Set update period
		setUpdatePeriod(obj, metadata.telemetryUpdatePeriod);
		// Connect queue
		eventMask = EV_UPDATED_MANUAL | EV_UPDATE_REQ;
		if (UAVObjIsMetaobject(obj)) {
			eventMask |= EV_UNPACKED;	// we also need to act on remote updates (unpack events)
		}
		UAVObjConnectQueue(obj, txqueue, eventMask);
	} else if (metadata.telemetryUpdateMode == UPDATEMODE_ONCHANGE) {
		// Set update period
		setUpdatePeriod(obj, 0);
		// Connect queue
		eventMask = EV_UPDATED | EV_UPDATED_MANUAL | EV_UPDATE_REQ;
		if (UAVObjIsMetaobject(obj)) {
			eventMask |= EV_UNPACKED;	// we also need to act on remote updates (unpack events)
		}
		UAVObjConnectQueue(obj, txqueue, eventMask);
	} else if (metadata.telemetryUpdateMode == UPDATEMODE_MANUAL) {
		// Set update period
		setUpdatePeriod(obj, 0);
		// Connect queue
		eventMask = EV_UPDATED_MANUAL | EV_UPDATE_REQ;
		if (UAVObjIsMetaobject(obj)) {
			eventMask |= EV_UNPACKED;	// we also need to act on remote updates (unpack events)
		}
		UAVObjConnectQueue(obj, txqueue, eventMask);
	} else if (metadata.telemetryUpdateMode == UPDATEMODE_NEVER) {
		// Set update period
		setUpdatePeriod(obj, 0);
		// Disconnect queue
		UAVObjDisconnectQueue(obj, txqueue);
	}
}

/**
 * Register a new object, adds object to local list and connects the queue depending on the object's
 * telemetry settings.
 * \param[in] obj Object to connect
 */
static void registerObject(UAVObjHandle obj)
{
	// Setup object for telemetry updates
	updateObject(obj);
}

/**
 * Module thread, should not return.
 */
static void transmitterControlsTask(void *parameters)
{
	ManualControlCommandData mcc;
	/*
    uint8_t Connected;
    float Roll;
    float Pitch;
    float Yaw;
    float Throttle;
    uint16_t Channel[8];
	*/

	AlarmsClear(SYSTEMALARMS_ALARM_ATTITUDE);

	PIOS_ADC_Config((PIOS_ADC_RATE / 1000.0f) * UPDATE_RATE);

	// Main task loop
	uint16_t cntr = 0;
	while (1) {
		PIOS_WDG_UpdateFlag(PIOS_WDG_ATTITUDE);

		// Only wait the time for two nominal updates before setting an alarm
		float gyro[5];
		if(xQueueReceive(adc_queue, (void * const) gyro, UPDATE_RATE * 2) == errQUEUE_EMPTY)
			AlarmsSet(SYSTEMALARMS_ALARM_ATTITUDE, SYSTEMALARMS_ALARM_ERROR);
		else {
			++cntr;
			ManualControlCommandGet(&mcc);
			mcc.Channel[0] = gyro[0];
			mcc.Channel[1] = gyro[1];
			mcc.Channel[2] = gyro[2];
			mcc.Channel[3] = gyro[3];
			ManualControlCommandSet(&mcc);
			if((cntr % 1000) == 0) {
				PIOS_COM_SendString(PIOS_COM_DEBUG, "ADC\n\r");
				//PIOS_COM_SendFormattedStringNonBlocking(PIOS_COM_DEBUG, "%d %d %d %d\n\r",
				//(uint32_t)gyro[0], (uint32_t)gyro[1], (uint32_t)gyro[2], (uint32_t)gyro[3]);
				cntr = 0;
			}
			AlarmsClear(SYSTEMALARMS_ALARM_ATTITUDE);
		}
	}
}

#ifdef NEVER
/**
 * Processes queue events
 */
static void processObjEvent(UAVObjEvent * ev)
{
	UAVObjMetadata metadata;
	int32_t retries;
	int32_t success;

	// Get object metadata
	UAVObjGetMetadata(ev->obj, &metadata);
	// Act on event
	retries = 0;
	success = -1;
	if (ev->event == EV_UPDATED || ev->event == EV_UPDATED_MANUAL) {
		PIOS_COM_SendString(PIOS_COM_DEBUG, "trans update\n\r");
		// Send update (with retries)
		while (retries < MAX_RETRIES && success == -1) {
			success = UAVTalkSendObject(&com, ev->obj, ev->instId, metadata.telemetryAcked, REQ_TIMEOUT_MS);	// call blocks until ack is received or timeout
			++retries;
		}
		// Update stats
		txRetries += (retries - 1);
		if (success == -1) {
			++txErrors;
		}
	} else if (ev->event == EV_UPDATE_REQ) {
		PIOS_COM_SendString(PIOS_COM_DEBUG, "trans req\n\r");
		// Request object update from GCS (with retries)
		while (retries < MAX_RETRIES && success == -1) {
			success = UAVTalkSendObjectRequest(&com, ev->obj, ev->instId, REQ_TIMEOUT_MS);	// call blocks until update is received or timeout
			++retries;
		}
		// Update stats
		txRetries += (retries - 1);
		if (success == -1) {
			++txErrors;
		}
	}
}

/**
 * Telemetry transmit task, regular priority
 */
static void transmitterTxTask(void *parameters)
{
	UAVObjEvent ev;

	// Loop forever
	while (1) {
		// Wait for queue message
		if (xQueueReceive(txqueue, &ev, portMAX_DELAY) == pdTRUE) {
			// Process event
			processObjEvent(&ev);
		}
	}
}

/**
 * Transmitter transmit task. Processes queue events and periodic updates.
 */
static void transmitterRxTask(void *parameters)
{
	uint32_t inputPort = 0;

	// Task loop
	while (1) {
#if defined(PIOS_INCLUDE_USB_HID)
		// Determine input port (USB takes priority over telemetry port)
		if (PIOS_USB_HID_CheckAvailable(0)) {
			inputPort = PIOS_COM_TELEM_RF;
		}
#endif /* PIOS_INCLUDE_USB_HID */

		if (inputPort) {
			// Block until data are available
			uint8_t serial_data[1];
			uint16_t bytes_to_process;

			bytes_to_process = PIOS_COM_ReceiveBuffer(inputPort, serial_data, sizeof(serial_data), 500);
			if (bytes_to_process > 0) {
				//PIOS_COM_SendFormattedStringNonBlocking(PIOS_COM_DEBUG, "Transmitter received %d bytes.\n\r", bytes_to_process);
				for (uint8_t i = 0; i < bytes_to_process; i++) {
					UAVTalkProcessInputStream(&com, serial_data[i]);
				}
			}
		} else {
			vTaskDelay(5);
		}
	}
}

/**
 * Transmit data buffer to the modem or USB port.
 * \param[in] data Data buffer to send
 * \param[in] length Length of buffer
 * \return 0 Success
 */
static int32_t transmitData(uint8_t * data, int32_t length)
{
	uint32_t outputPort = 0;

#if defined(PIOS_INCLUDE_USB_HID)
	if (PIOS_USB_HID_CheckAvailable(0)) {
		outputPort = PIOS_COM_TELEM_RF;
	}
#endif /* PIOS_INCLUDE_USB_HID */

	//PIOS_COM_SendFormattedStringNonBlocking(PIOS_COM_DEBUG, "Transmitter sending %d bytes.\n\r", length);
	if (outputPort) {
		return PIOS_COM_SendBufferNonBlocking(outputPort, data, length);
	} else {
		return -1;
	}
	return 0;
}
#endif

/**
 * @}
 * @}
 */
