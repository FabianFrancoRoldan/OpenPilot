/**
 ******************************************************************************
 * @addtogroup OpenPilotModules OpenPilot Modules
 * @{
 * @addtogroup StateT3 Copter Control State Estimation
 * @brief Acquires sensor data and computes attitude estimate
 * Specifically updates the the @ref PositionActual "PositionActual" and @ref VelocityActual "VelocityActual" settings objects
 * @{
 *
 * @file       attitude.c
 * @author     The OpenPilot Team, http://www.openpilot.org Copyright (C) 2010.
 * @brief      Module to handle all comms to the AHRS on a periodic basis.
 *
 * @see        The GNU Public License (GPL) Version 3
 *
 ******************************************************************************/
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

/**
 * Input objects: None, takes sensor data via pios
 * Output objects: @ref PositionActual @ref VelocityActual
 *
 * This module computes an attitude estimate from the sensor data
 *
 * The module executes in its own thread.
 *
 * UAVObjects are automatically generated by the UAVObjectGenerator from
 * the object definition XML file.
 *
 * Modules have no API, all communication to other modules is done through UAVObjects.
 * However modules may use the API exposed by shared libraries.
 * See the OpenPilot wiki for more details.
 * http://www.openpilot.org/OpenPilot_Application_Architecture
 *
 */

#include "pios.h"
#include "positionactual.h"
#include "velocityactual.h"
#include "gpsposition.h"
#include "gpsvelocity.h"
#include "hwsettings.h"
#include "homelocation.h"

// Private constants
#define STACK_SIZE_BYTES 500
#define TASK_PRIORITY (tskIDLE_PRIORITY+2)

#define LOOP_RATE_MS      100

//#define PI_MOD(x) (fmod(x + M_PI, M_PI * 2) - M_PI)
// Private types

// Private variables
static xTaskHandle t3taskHandle;
static HomeLocationData homeLocation;

// Private functions
static void StateT3Task(void *parameters);
static int32_t getNED(GPSPositionData * gpsPosition, float * NED);
static void settingsUpdatedCb(UAVObjEvent * objEv);
static void GPSPositionUpdatedCb(UAVObjEvent * objEv);
static bool gpsNew_flag;

//static xQueueHandle gpsQueue;

/**
 * Initialise the module, called on startup
 * \returns 0 on success or -1 if initialisation failed
 */
int32_t StateT3Start(void)
{
//	//Create the queue for the sensors
//	gpsQueue = xQueueCreate(1, sizeof(UAVObjEvent));

	// Start main task
	xTaskCreate(StateT3Task, (signed char *)"StateT3", STACK_SIZE_BYTES/4, NULL, TASK_PRIORITY, &t3taskHandle);
	TaskMonitorAdd(TASKINFO_RUNNING_STATET3, t3taskHandle);

//	//Connect queues
//	GPSPositionConnectQueue(gpsQueue);

	return 0;
}

/**
 * Initialise the module, called on startup
 * \returns 0 on success or -1 if initialization failed
 */
int32_t StateT3Initialize(void)
{
	
	HwSettingsInitialize();
	bool gpsEnabled;
	uint8_t gpsPort;
	gpsPort = PIOS_COM_GPS;
	
#ifdef MODULE_GPS_BUILTIN
	gpsEnabled = true;
#else
	uint8_t optionalModules[HWSETTINGS_OPTIONALMODULES_NUMELEM];
	HwSettingsOptionalModulesGet(optionalModules);
	
	if (optionalModules[HWSETTINGS_OPTIONALMODULES_GPS] == HWSETTINGS_OPTIONALMODULES_ENABLED)
		gpsEnabled = true;
	else
		gpsEnabled = false;
#endif
	
//	if (gpsPort && gpsEnabled) {
		//Initialize UAVObjects
		PositionActualInitialize();
		VelocityActualInitialize();
		GPSPositionInitialize();
		GPSVelocityInitialize();
		HomeLocationInitialize();
		
		HomeLocationConnectCallback(&settingsUpdatedCb);
		GPSPositionConnectCallback(&GPSPositionUpdatedCb);
		
		gpsNew_flag=false;
		
		return 0;
//	}
//	
//	return -1;
	
}

MODULE_INITCALL(StateT3Initialize, StateT3Start)

/**
 * Module thread, should not return.
 */
 
int32_t accel_test;
int32_t gyro_test;
static void StateT3Task(void *parameters)
{
	
//	AlarmsClear(SYSTEMALARMS_ALARM_STATET3);
	
	// Force settings update to make sure rotation loaded
	settingsUpdatedCb(HomeLocationHandle());

	// --------------------------- //
	// Main task loop. Never exits //
	// --------------------------- //
	
	while (1) {
		vTaskDelay(LOOP_RATE_MS);
//		while (	xQueueReceive(gpsQueue, &ev, 0 / portTICK_RATE_MS) != pdTRUE);
//		while (	gpsNew_flag == false);


		GPSPositionData gpsPositionData;
		GPSVelocityData gpsVelocityData;

		GPSPositionGet(&gpsPositionData);
		GPSVelocityGet(&gpsVelocityData);
		
		float NED[3];
		getNED(&gpsPositionData, NED);

		PositionActualData positionActualData;
		VelocityActualData velocityActualData;

		PositionActualGet(&positionActualData);
		VelocityActualGet(&velocityActualData);
		
		float dT=.100;
		float tauPosNorthEast=0.3;
		float tauPosDown=0.5;
		float tauVelNorthEast=0.3;
		float tauVelDown=0.5;
		float alphaPosNorthEast=dT/(dT + tauPosNorthEast);
		float alphaPosDown=dT/(dT + tauPosDown);
		float alphaVelNorthEast=dT/(dT + tauVelNorthEast);
		float alphaVelDown=dT/(dT + tauVelDown);

		velocityActualData.North=(1-alphaVelNorthEast)*velocityActualData.North + alphaVelNorthEast*gpsVelocityData.North;
		velocityActualData.East=(1-alphaVelNorthEast)*velocityActualData.East + alphaVelNorthEast*gpsVelocityData.East;
		velocityActualData.Down=(1-alphaVelDown)*velocityActualData.Down + alphaVelDown*gpsVelocityData.Down;
		
		positionActualData.North=(1-alphaPosNorthEast)*(positionActualData.North+(velocityActualData.North*dT)) + alphaPosNorthEast*NED[0];
		positionActualData.East=(1-alphaPosNorthEast)*(positionActualData.East+(velocityActualData.East*dT)) + alphaPosNorthEast*NED[1];
		positionActualData.Down=(1-alphaPosDown)*(positionActualData.Down+(velocityActualData.Down*dT)) + alphaPosDown*NED[2];
	
		// Do not update position and velocity estimates when in simulation mode
		if (!PositionActualReadOnly()){
			float delT;
			portTickType thisSysTime = xTaskGetTickCount();
			static portTickType lastSysTime = 0;
			
			delT = (thisSysTime == lastSysTime) ? 0.001 : (portMAX_DELAY & (thisSysTime - lastSysTime)) / portTICK_RATE_MS / 1000.0f;
			lastSysTime = thisSysTime;
			
			PositionActualSet(&positionActualData);
			VelocityActualSet(&velocityActualData);
			
		}
		
//		AlarmsClear(SYSTEMALARMS_ALARM_STATET3);
		
		gpsNew_flag=false;
	}
}

/**
 * @brief Convert the GPS LLA position into NED coordinates
 * @note this method uses a taylor expansion around the home coordinates
 * to convert to NED which allows it to be done with all floating
 * calculations
 * @param[in] Current GPS coordinates, (Lat, Lon, Alt)
 * @param[out] NED frame coordinates
 * @returns 0 for success, -1 for failure
 */
float T[3];
const float DEG2RAD = 3.141592653589793f / 180.0f;
static int32_t getNED(GPSPositionData *gpsPosition, float * NED)
{
	float dL[3] = {(gpsPosition->Latitude - homeLocation.Latitude) / 10.0e6f * DEG2RAD,
		(gpsPosition->Longitude - homeLocation.Longitude) / 10.0e6f * DEG2RAD,
		(gpsPosition->Altitude + gpsPosition->GeoidSeparation - homeLocation.Altitude)};
	
	NED[0] = T[0] * dL[0];
	NED[1] = T[1] * dL[1];
	NED[2] = T[2] * dL[2];
	
	return 0;
}

static void GPSPositionUpdatedCb(UAVObjEvent * objEv) 
{
	gpsNew_flag=true;
}

static void settingsUpdatedCb(UAVObjEvent * objEv) 
{
	float lat, alt;
	
	HomeLocationGet(&homeLocation);

	// Compute vector for converting deltaLLA to NED
	lat = homeLocation.Latitude / 10.0e6f * DEG2RAD;
	alt = homeLocation.Altitude;
	
	T[0] = alt+6.378137E6f;
	T[1] = cosf(lat)*(alt+6.378137E6f);
	T[2] = -1.0f;
}

/**
 * @}
 * @}
 */
