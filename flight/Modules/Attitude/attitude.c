/**
 ******************************************************************************
 * @addtogroup OpenPilotModules OpenPilot Modules
 * @{
 * @addtogroup Attitude Copter Control Attitude Estimation
 * @brief Acquires sensor data and computes attitude estimate
 * Specifically updates the the @ref AttitudeActual "AttitudeActual" and @ref AttitudeRaw "AttitudeRaw" settings objects
 * @{
 *
 * @file       attitude.c
 * @author     The OpenPilot Team, http://www.openpilot.org Copyright (C) 2010.
 * @brief      Module to handle all comms to the AHRS on a periodic basis.
 *
 * @see        The GNU Public License (GPL) Version 3
 *
 ******************************************************************************/
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

/**
 * Input objects: None, takes sensor data via pios
 * Output objects: @ref AttitudeRaw @ref AttitudeActual
 *
 * This module computes an attitude estimate from the sensor data
 *
 * The module executes in its own thread.
 *
 * UAVObjects are automatically generated by the UAVObjectGenerator from
 * the object definition XML file.
 *
 * Modules have no API, all communication to other modules is done through UAVObjects.
 * However modules may use the API exposed by shared libraries.
 * See the OpenPilot wiki for more details.
 * http://www.openpilot.org/OpenPilot_Application_Architecture
 *
 */

#include "pios.h"
#include "attitude.h"
#include "sensordrift.h"
#include "sensorfetch.h"
#include "gyros.h"
#include "accels.h"
#include "attitudeactual.h"
#include "attitudesettings.h"
#include "flightstatus.h"
#include "manualcontrolcommand.h"
#include "CoordinateConversions.h"
#include <pios_board_info.h>
#include "dcmstatus.h"
#include "dcmsettings.h"

// Private constants
#define STACK_SIZE_BYTES 800
#define TASK_PRIORITY (tskIDLE_PRIORITY+3)

#define SENSOR_PERIOD     4
#define LOOP_RATE_MS      25.0f
#define GYRO_NEUTRAL_BIAS 1665
#define GRAV             -9.805f
#define DEG2RAD          (3.141592654f/180.0f)

#define PI_MOD(x) (fmod(x + M_PI, M_PI * 2) - M_PI)
// Private types

// Private variables
static xTaskHandle taskHandle;

// Private functions
static void AttitudeTask(void *parameters);

static xQueueHandle gyro_queue;

static int32_t updateSensors(AccelsData * accelsData, GyrosData * gyrosData, bool cc3d_flag);
static void updateAttitude(float * gyros, float dT);
static void settingsUpdatedCb(UAVObjEvent * objEv);

struct GlobalAttitudeVariables *glbl;


int32_t const MAX_TRIM_FLIGHT_SAMPLES = 65535;


/**
 * Initialise the module, called on startup
 * \returns 0 on success or -1 if initialisation failed
 */
int32_t AttitudeStart(void)
{
	
	// Start main task
	xTaskCreate(AttitudeTask, (signed char *)"Attitude", STACK_SIZE_BYTES/4, NULL, TASK_PRIORITY, &taskHandle);
	TaskMonitorAdd(TASKINFO_RUNNING_ATTITUDE, taskHandle);
	PIOS_WDG_RegisterFlag(PIOS_WDG_ATTITUDE);

	return 0;
}

/**
 * Initialise the module, called on startup
 * \returns 0 on success or -1 if initialisation failed
 */
int32_t AttitudeInitialize(void)
{
	//Initialize UAVObjects
	AttitudeActualInitialize();
	AttitudeSettingsInitialize();
	AccelsInitialize();
	GyrosInitialize();
	DCMStatusInitialize();
	DCMSettingsInitialize();

	glbl=(struct GlobalAttitudeVariables*) pvPortMalloc(sizeof(struct GlobalAttitudeVariables));

	// Initialize quaternion
	AttitudeActualData attitude;
	AttitudeActualGet(&attitude);
	attitude.q1 = 1;
	attitude.q2 = 0;
	attitude.q3 = 0;
	attitude.q4 = 0;
	AttitudeActualSet(&attitude);

	//--------
	// If bootloader runs, cannot trust the global values to init to 0.
	//--------
	memset(glbl->gyro_correct_int, 0, sizeof(glbl->gyro_correct_int));
	

	//Initialize variables. //IS THIS EVEN NECESSARY, SINCE WE CALL settingsUpdatedCb BELOW BEFORE THE MAIN LOOP?
	glbl->accelKi = 0;
	glbl->accelKp = 0;
	glbl->yawBiasRate = 0;
	glbl->rotate = false;
	glbl->zero_during_arming = false;
	glbl->bias_correct_gyro = true;	
		
	glbl->q[0] = 1;
	glbl->q[1] = 0;
	glbl->q[2] = 0;
	glbl->q[3] = 0;
	for(uint8_t i = 0; i < 3; i++)
		for(uint8_t j = 0; j < 3; j++)
			glbl->Rsb[i][j] = 0;
	
	glbl->trim_requested = false;
	
	AttitudeSettingsConnectCallback(&settingsUpdatedCb);
	
	return 0;
}

MODULE_INITCALL(AttitudeInitialize, AttitudeStart)

/**
 * Module thread, should not return.
 */
 
int32_t accel_test;
int32_t gyro_test;
static void AttitudeTask(void *parameters)
{
	uint8_t init = 0;
	AlarmsClear(SYSTEMALARMS_ALARM_ATTITUDE);
	
	// Set critical error and wait until the accel is producing data
	//THIS IS BOARD SPECIFIC AND DOES NOT BELONG HERE. Can we put it in #if defined(PIOS_INCLUDE_ADXL345)?
	while(PIOS_ADXL345_FifoElements() == 0) {
		AlarmsSet(SYSTEMALARMS_ALARM_ATTITUDE, SYSTEMALARMS_ALARM_CRITICAL);
		PIOS_WDG_UpdateFlag(PIOS_WDG_ATTITUDE);
	}
	
	const struct pios_board_info * bdinfo = &pios_board_info_blob;
	
	//Test if board is CopterControl or CC3D
	bool cc3d_flag = (bdinfo->board_rev == 0x02);

	if(cc3d_flag)
		glbl->gyroGain_ref=1.0f;
	else
		glbl->gyroGain_ref=0.42f;
	AttitudeSettingsGyroGainSet(&glbl->gyroGain_ref);	
	
	// Force settings update to make sure rotation loaded
	settingsUpdatedCb(AttitudeSettingsHandle());
	
	if(cc3d_flag) {
#if defined(PIOS_INCLUDE_MPU6000)
		gyro_test = PIOS_MPU6000_Test();
#endif
	} else {
#if defined(PIOS_INCLUDE_ADXL345)
		accel_test = PIOS_ADXL345_Test();
#endif

#if defined(PIOS_INCLUDE_ADC)
		// Create queue for passing gyro data, allow 2 back samples in case
		gyro_queue = xQueueCreate(1, sizeof(float) * 4);
		PIOS_Assert(gyro_queue != NULL);
		PIOS_ADC_SetQueue(gyro_queue);
		PIOS_ADC_Config((PIOS_ADC_RATE / 1000.0f) * LOOP_RATE_MS);
#endif

	}

	//Store the original filter specs. This is because we currently have a poor way of calibrating the Premerlani approach
	uint8_t originalFilter=glbl->filter_choice;

	// --------------------------- //
	// Main task loop. Never exits //
	// --------------------------- //
	while (1) {
		FlightStatusData flightStatus;
		FlightStatusGet(&flightStatus);

		//Change gyro calibration parameters...
		if((xTaskGetTickCount() > 1000) && (xTaskGetTickCount() < 7000)) { //...during first 7 seconds or so...
			
			// For first 7 seconds use accels to get gyro bias
			glbl->accelKp = 1;
			glbl->accelKi = 0.9;
			glbl->yawBiasRate = 0.23;
			init = 0;
			
			//Force to use the CCC, because of the way it calibrates
			glbl->filter_choice=ATTITUDESETTINGS_FILTERCHOICE_CCC;
		}
		else if (glbl->zero_during_arming && (flightStatus.Armed == FLIGHTSTATUS_ARMED_ARMING)) { //...during arming...
			glbl->accelKp = 1;
			glbl->accelKi = 0.9;
			glbl->yawBiasRate = 0.23;
			init = 0;
			
			//Force to use the CCC, because of the way it calibrates
			glbl->filter_choice=ATTITUDESETTINGS_FILTERCHOICE_CCC;
		} else if (init == 0) { //...once fully armed.
			// Reload settings (all the rates)
			AttitudeSettingsAccelKiGet(&glbl->accelKi);
			AttitudeSettingsAccelKpGet(&glbl->accelKp);
			AttitudeSettingsYawBiasRateGet(&glbl->yawBiasRate);

			glbl->filter_choice=originalFilter;
			
			init = 1;
		}
		
		PIOS_WDG_UpdateFlag(PIOS_WDG_ATTITUDE);

		AccelsData accels;
		GyrosData gyros;
		int32_t retval = 0;
		
		//Get sensor data, rotate, filter, and output to UAVO. This is the function that calls the wait structures that limit the loop rate
		retval = updateSensors(&accels, &gyros, cc3d_flag);

		// Update attitude. Only do so when sensor data is good
		if (retval != 0)
			AlarmsSet(SYSTEMALARMS_ALARM_ATTITUDE, SYSTEMALARMS_ALARM_ERROR);
		else {
			// Do not update attitude data in simulation mode /*WHY DO WE EVEN ALLOW SIMULATION TO GET THIS FAR? WOULDN'T IT BE BETTER TO DISABLE THIS ENTIRE FUNCTION IF IN SIMULATION?*/
			if (!AttitudeActualReadOnly()){
				float delT;
				portTickType thisSysTime = xTaskGetTickCount();
				static portTickType lastSysTime = 0;
				
				delT = (thisSysTime == lastSysTime) ? 0.001 : (portMAX_DELAY & (thisSysTime - lastSysTime)) / portTICK_RATE_MS / 1000.0f;
				lastSysTime = thisSysTime;
				
				//Update sensor estimation with drift PI feedback
				if(glbl->bias_correct_gyro) { 
					updateSensorDrift(&accels, &gyros, delT);
				}
//				applyDrift(&accels, &gyros);
				
				//Update UAVOs with most accurate sensor data
				AccelsSet(&accels);
				GyrosSet(&gyros);
				
//				float gyrosVec[3] = {gyros.x, gyros.y, gyros.z};
				updateAttitude(&gyros.x, delT);
			}

			AlarmsClear(SYSTEMALARMS_ALARM_ATTITUDE);
		}
	}
}

float gyros_passed[3];

static int32_t updateSensors(AccelsData * accels, GyrosData * gyros, bool cc3d_flag){
	int8_t retval;
	float prelim_accels[4];
	float prelim_gyros[4];
	if(cc3d_flag){
		retval=getSensorsCC3D(prelim_accels, prelim_gyros);
	}
	else {
		retval=getSensorsCC(prelim_accels, prelim_gyros, &gyro_queue);
	}
	
	if (retval < 0) { //No sensor data!
		return retval;
	}

	//Rotate sensor board into body frame
	if(glbl->rotate){
		float tmpVec[3];
		
		//Rotate the vector into a temporary vector, and then copy back into the original vectors.
		rot_mult(glbl->Rsb, prelim_accels, tmpVec, true);
		memcpy(prelim_accels, tmpVec, sizeof(tmpVec));
		
		rot_mult(glbl->Rsb, prelim_gyros,  tmpVec, true);
		memcpy(prelim_gyros,  tmpVec, sizeof(tmpVec));
	}

	//Correct accels biases. 
	// NOTE: At this point, prelim_accels has now been rotated into the body frame, as are the accel biases
	accels->x = prelim_accels[0] - glbl->accelbias[0];
	accels->y = prelim_accels[1] - glbl->accelbias[1];
	accels->z = prelim_accels[2] - glbl->accelbias[2];

	//Correct gyroscope biases. 
	// NOTE: At this point, prelim_gyros has now been rotated into the body frame, as are the gyro biases
	if(glbl->bias_correct_gyro) { 
		// Applying integral component here so it can be seen on the gyros and correct bias
		gyros->x = prelim_gyros[0] + glbl->gyro_correct_int[0];
		gyros->y = prelim_gyros[1] + glbl->gyro_correct_int[1];
		gyros->z = prelim_gyros[2] + glbl->gyro_correct_int[2];
	}
	else {
		gyros->x = prelim_gyros[0];
		gyros->y = prelim_gyros[1];
		gyros->z = prelim_gyros[2];
		
	}

	
	//CopterControl has a function which can generate on the fly a correct hovering accelerometer bias for
	//quadcopters and helicopters. See more on the wiki and forums: ???
	if (glbl->trim_requested) {
		if (glbl->trim_samples >= MAX_TRIM_FLIGHT_SAMPLES) {
			glbl->trim_requested = false;
		} else {
			uint8_t armed;
			float throttle;
			FlightStatusArmedGet(&armed);
			ManualControlCommandThrottleGet(&throttle);  // Until flight status indicates airborne
			if ((armed == FLIGHTSTATUS_ARMED_ARMED) && (throttle > 0)) {
				glbl->trim_samples++;
				// Store the digitally scaled version since that is what we use for bias
				glbl->trim_accels[0] += accels->x;
				glbl->trim_accels[1] += accels->y;
				glbl->trim_accels[2] += accels->z;
			}
		}
	}
	
	return 0;
	
}


static void updateAttitude(float * gyros, float dT)
{
	
	{ // scoping variables to save memory
		// Work out time derivative from INSAlgo writeup
		// Also accounts for the fact that gyros are in deg/s
		float qdot[4];
		qdot[0] = (-glbl->q[1] * gyros[0] - glbl->q[2] * gyros[1] - glbl->q[3] * gyros[2]) * dT * M_PI / 180 / 2;
		qdot[1] = (glbl->q[0] * gyros[0] - glbl->q[3] * gyros[1] + glbl->q[2] * gyros[2]) * dT * M_PI / 180 / 2;
		qdot[2] = (glbl->q[3] * gyros[0] + glbl->q[0] * gyros[1] - glbl->q[1] * gyros[2]) * dT * M_PI / 180 / 2;
		qdot[3] = (-glbl->q[2] * gyros[0] + glbl->q[1] * gyros[1] + glbl->q[0] * gyros[2]) * dT * M_PI / 180 / 2;
		
		// Integrate a time step
		glbl->q[0] = glbl->q[0] + qdot[0];
		glbl->q[1] = glbl->q[1] + qdot[1];
		glbl->q[2] = glbl->q[2] + qdot[2];
		glbl->q[3] = glbl->q[3] + qdot[3];
		
		if(glbl->q[0] < 0) {
			glbl->q[0] = -glbl->q[0];
			glbl->q[1] = -glbl->q[1];
			glbl->q[2] = -glbl->q[2];
			glbl->q[3] = -glbl->q[3];
		}
	}
	
	// Renomalize
	float qmag = sqrtf(powf(glbl->q[0],2.0f) + powf(glbl->q[1],2.0f) + powf(glbl->q[2],2.0f) + powf(glbl->q[3],2.0f));
	glbl->q[0] = glbl->q[0] / qmag;
	glbl->q[1] = glbl->q[1] / qmag;
	glbl->q[2] = glbl->q[2] / qmag;
	glbl->q[3] = glbl->q[3] / qmag;
	
	// If quaternion has become inappropriately short or is nan reinit.
	// THIS SHOULD NEVER ACTUALLY HAPPEN
	if((fabs(qmag) < 1e-3) || (qmag != qmag)) {
		glbl->q[0] = 1;
		glbl->q[1] = 0;
		glbl->q[2] = 0;
		glbl->q[3] = 0;
	}
	
	AttitudeActualData attitudeActual;
	AttitudeActualGet(&attitudeActual);
	
	quat_copy(glbl->q, &attitudeActual.q1);
	
	// Convert into eueler degrees (makes assumptions about RPY order)
	Quaternion2RPY(&attitudeActual.q1,&attitudeActual.Roll);
	
	AttitudeActualSet(&attitudeActual);
}

static void settingsUpdatedCb(UAVObjEvent * objEv) {
	AttitudeSettingsData attitudeSettings;
	AttitudeSettingsGet(&attitudeSettings);
	
	glbl->accelKp = attitudeSettings.AccelKp;
	glbl->accelKi = attitudeSettings.AccelKi;
	glbl->yawBiasRate = attitudeSettings.YawBiasRate;
	glbl->gyroGain[0] = glbl->gyroGain[1] = glbl->gyroGain[2] = glbl->gyroGain_ref = attitudeSettings.GyroGain;		

	glbl->zero_during_arming = (attitudeSettings.ZeroDuringArming == ATTITUDESETTINGS_ZERODURINGARMING_TRUE);
	glbl->bias_correct_gyro = (attitudeSettings.BiasCorrectGyro == ATTITUDESETTINGS_BIASCORRECTGYRO_TRUE);
	glbl->filter_choice = attitudeSettings.FilterChoice;

	glbl->accelbias[0] = attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_X]/1000.0f; //Divide by 1000 because `accelbias` is in units
	glbl->accelbias[1] = attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_Y]/1000.0f; // of 1000*[m/s^2]
	glbl->accelbias[2] = attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_Z]/1000.0f;
	
	glbl->gyro_correct_int[0] = attitudeSettings.GyroBias[ATTITUDESETTINGS_GYROBIAS_X] / 100.0f; //Divide by 100 because `GyroBias` 
	glbl->gyro_correct_int[1] = attitudeSettings.GyroBias[ATTITUDESETTINGS_GYROBIAS_Y] / 100.0f; // is in units of 100*[deg/s]
	glbl->gyro_correct_int[2] = attitudeSettings.GyroBias[ATTITUDESETTINGS_GYROBIAS_Z] / 100.0f;
	
	//Calculate sensor to board rotation matrix. If the matrix is the identity, don't expend cycles on rotation
	if(attitudeSettings.BoardRotation[0] == 0 && attitudeSettings.BoardRotation[1] == 0 &&
	   attitudeSettings.BoardRotation[2] == 0) {
		glbl->rotate = false;
		
		// Shouldn't need to be used, but just to be safe we will anyway
		float rotationQuat[4] = {1,0,0,0};
		Quaternion2R(rotationQuat, glbl->Rsb);
	} else {
		float rpy[3] = {attitudeSettings.BoardRotation[ATTITUDESETTINGS_BOARDROTATION_ROLL]*DEG2RAD,
			attitudeSettings.BoardRotation[ATTITUDESETTINGS_BOARDROTATION_PITCH]*DEG2RAD,
			attitudeSettings.BoardRotation[ATTITUDESETTINGS_BOARDROTATION_YAW]*DEG2RAD};
		Euler2R(rpy, glbl->Rsb);
		glbl->rotate = true;
	}
	
	if (attitudeSettings.TrimFlight == ATTITUDESETTINGS_TRIMFLIGHT_START) {
		glbl->trim_accels[0] = 0;
		glbl->trim_accels[1] = 0;
		glbl->trim_accels[2] = 0;
		glbl->trim_samples = 0;
		glbl->trim_requested = true;
	} else if (attitudeSettings.TrimFlight == ATTITUDESETTINGS_TRIMFLIGHT_LOAD) {
		glbl->trim_requested = false;
		attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_X] = glbl->trim_accels[0] / glbl->trim_samples;
		attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_Y] = glbl->trim_accels[1] / glbl->trim_samples;
		// Z should average -g
		attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_Z] = glbl->trim_accels[2] / glbl->trim_samples - GRAV;
		attitudeSettings.TrimFlight = ATTITUDESETTINGS_TRIMFLIGHT_NORMAL;
		AttitudeSettingsSet(&attitudeSettings);
	} else {
		glbl->trim_requested = false;
	}
}

/**
 * @}
 * @}
 */
