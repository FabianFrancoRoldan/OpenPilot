/**
 ******************************************************************************
 * @addtogroup OpenPilotModules OpenPilot Modules
 * @{
 * @addtogroup Attitude Copter Control Attitude Estimation
 * @brief A collection of mathematics that help reduce sensor drift. Pick and choose for best performance
 * @{
 *
 * @file       sensordrift.c
 * @author     The OpenPilot Team, http://www.openpilot.org Copyright (C) 2010.
 * @brief      Module to handle all comms to the AHRS on a periodic basis.
 *
 * @see        The GNU Public License (GPL) Version 3
 *
 ******************************************************************************/
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

/**
 * UAVObjects are automatically generated by the UAVObjectGenerator from
 * the object definition XML file.
 *
 * Modules have no API, all communication to other modules is done through UAVObjects.
 * However modules may use the API exposed by shared libraries.
 * See the OpenPilot wiki for more details.
 * http://www.openpilot.org/OpenPilot_Application_Architecture
 *
 */

#include "pios.h"
#include "hwsettings.h"
#include "sensordrift.h"
#include "attitude.h"
#include "attitudeactual.h"
#include "attitudesettings.h"
#include "flightstatus.h"
#include "gpsvelocity.h"
#include "manualcontrolcommand.h"
#include "CoordinateConversions.h"
#include <pios_board_info.h>

//Global variables
extern struct GlobalAttitudeVariables *glbl;
bool firstpass_flag=true;

struct GlobalDcmDriftVariables {
	xQueueHandle gpsVelQueue;
	
//	float gyros_passed[3];
	float GPSV_old[3];
	
	float accels_e_integrator[3];
	float gyros_b_integrator[3];
	float omegaCorrP[3];
	float omegaCorrI[3];
	
	bool gpspresent_flag;
};

struct GlobalDcmDriftVariables * drft;

// Private constants

// Private types

// Private variables
#define GRAV         9.805f /* 0.004f is gravity / LSB */
#define MAXIMUM_SPIN_DCM_INTEGRAL 20.0f //in [deg/s]
#define KIROLLPITCH 1
#define KIYAW 1
#define KPROLLPITCH 1
#define KPYAW 1

#define DRIFT_TYPE CCC
enum DRIFT_CORRECTION_ALGOS {
	CCC,
	PREMERLANI
};

// Private functions
void gyro_drift(float gyro[3], float errYaw_b[3], float errRollPitch_b[3], float normOmegaScalar, float *omegaCorrP, float *omegaCorrI);
void yaw_drift(float gpsV[3], float Rbe[3][3], float *errYaw_b);
void calibrate_gyros_high_speed(float gyro[3], float omegaCorrP[3], float normOmegaScalar, float *ggain);

void updateSensorDrift(AccelsData * accelsData, GyrosData * gyrosData, const float delT){
	// Bad practice to assume structure order, but saves memory. //WHY DOES THIS SAVE MEMORY?
	float * gyros = &gyrosData->x;
	float * accels = &accelsData->x;	
	
	if (DRIFT_TYPE==CCC) {
			CottonComplementaryCorrection(accels, gyros, delT);
	}
	else if(DRIFT_TYPE == PREMERLANI){	
		if (firstpass_flag){
			
//			HwSettingsInitialize(); //SHOULD THIS BE COMMENTED OUT OR NOT?
			uint8_t optionalModules[HWSETTINGS_OPTIONALMODULES_NUMELEM];
			HwSettingsOptionalModulesGet(optionalModules);
			
			
			//Allocate memory for DCM drift globals
			drft = (struct GlobalDcmDriftVariables *) malloc(sizeof(struct GlobalDcmDriftVariables));
			
			memset(drft->GPSV_old, 0, sizeof(drft->GPSV_old));
			memset(drft->GPSV_old, 0, sizeof(drft->GPSV_old));
			memset(drft->accels_e_integrator, 0, sizeof(drft->accels_e_integrator));
			
			//Create and connect queue
			if (optionalModules[HWSETTINGS_OPTIONALMODULES_GPS] == HWSETTINGS_OPTIONALMODULES_ENABLED) {
				drft->gpsVelQueue = xQueueCreate(1, sizeof(UAVObjEvent));
				GPSVelocityConnectQueue(drft->gpsVelQueue);
				drft->gpspresent_flag = true;
			}
			else{
				drft->gpspresent_flag = false;
			}
						
			//Turn off first pass flag
			firstpass_flag=false;
		}
		
		
		//Convert quaternions into rotation matrix
		float Rbe[3][3];
		Quaternion2R(glbl->q, Rbe);
		
		DcmCorrection(accels, gyros, Rbe, delT);
	}
}


/*
 * Correct sensor drift, using the 3C approach from J. Cotton
 */

void CottonComplementaryCorrection(float * accels, float * gyros, const float delT)
{
	
	// Because most crafts wont get enough information from gravity to zero yaw gyro, we try
	// and make it average zero (weakly)
	glbl->gyro_correct_int[2] += - gyros[2] * glbl->yawBiasRate;	
	
	float grot[3];
	float accel_err[3];
	
	// Rotate gravity to body frame and cross with accels
	grot[0] = -(2 * (glbl->q[1] * glbl->q[3] - glbl->q[0] * glbl->q[2]));
	grot[1] = -(2 * (glbl->q[2] * glbl->q[3] + glbl->q[0] * glbl->q[1]));
	grot[2] = -(glbl->q[0] * glbl->q[0] - glbl->q[1]*glbl->q[1] - glbl->q[2]*glbl->q[2] + glbl->q[3]*glbl->q[3]);
	CrossProduct((const float *) accels, (const float *) grot, accel_err);
	
	// Account for accel magnitude
	float accel_mag = sqrtf(accels[0]*accels[0] + accels[1]*accels[1] + accels[2]*accels[2]);
	if(accel_mag < 1.0e-3f)
		return;
	
	accel_err[0] /= accel_mag;
	accel_err[1] /= accel_mag;
	accel_err[2] /= accel_mag;
	
	// Accumulate integral of error.  Scale here so that units are (deg/s) but accelKi has units of s
	glbl->gyro_correct_int[0] += accel_err[0] * glbl->accelKi;
	glbl->gyro_correct_int[1] += accel_err[1] * glbl->accelKi;
	
	//gyro_correct_int[2] += accel_err[2] * accelKi;
	
	// Correct rates based on error, integral component dealt with in updateSensors
	gyros[0] += accel_err[0] * glbl->accelKp / delT;
	gyros[1] += accel_err[1] * glbl->accelKp / delT;
	gyros[2] += accel_err[2] * glbl->accelKp / delT;
}


/*
 * Correct sensor drift, using the DCM approach from W. Premerlani et. al
 */

void DcmCorrection(float * accels, float * gyros, float Rbe[3][3], const float delT)
{
//	float grot[3];
//	float accel_err[3];
//	
	bool correctGyroDriftDCM_flag=FALSE;
//
//
	float errRollPitch_e[3];
	float errRollPitch_b[3];
	float errYaw_b[3];
	float omegaCorrP[3];
	float omegaCorrI[3];
	
	//Correct roll-pitch-yaw drift
	{
		//Check if the GPS has new information. If so, execute IF statement
		//The math is derived from Roll-Pitch Gyro Drift Compensation, Rev.3, by W. Premerlani
		if (drft->gpspresent_flag){
			UAVObjEvent ev;
			float accels_e[3];
			
			//Rotate accelerometer readings into Earth frame. Note that we need to take the transpose of Rbe.
			rot_mult(Rbe, accels, accels_e, TRUE);
			
			//Integrate accelerometer measurements in Earth frame
			drft->accels_e_integrator[0]+=accels_e[0]*delT;
			drft->accels_e_integrator[1]+=accels_e[1]*delT;
			drft->accels_e_integrator[2]+=accels_e[2]*delT;
			
			if(xQueueReceive(drft->gpsVelQueue, &ev, 0) == pdTRUE) {
				float dGPSdt_e[3];
				
				GPSVelocityData gpsVelocity;
				GPSVelocityGet(&gpsVelocity);
				
				dGPSdt_e[0]=-(gpsVelocity.North-drft->GPSV_old[0])/delT;
				dGPSdt_e[1]=-(gpsVelocity.East-drft->GPSV_old[1])/delT;
				dGPSdt_e[2]=GRAV-(gpsVelocity.Down-drft->GPSV_old[2])/delT;
				
				drft->GPSV_old[0]=gpsVelocity.North;
				drft->GPSV_old[1]=gpsVelocity.East;
				drft->GPSV_old[2]=gpsVelocity.Down;
				
				float normdGPSdt_e=sqrtf(dGPSdt_e[0]*dGPSdt_e[0]+dGPSdt_e[1]*dGPSdt_e[1]+dGPSdt_e[2]*dGPSdt_e[2]);
				
				//Take cross product of integrated accelerometer measurements with integrated earth frame accelerations
				CrossProduct(drft->accels_e_integrator, dGPSdt_e, errRollPitch_e);
				
				//Scale cross product
				errRollPitch_e[0] /= normdGPSdt_e*delT;
				errRollPitch_e[1] /= normdGPSdt_e*delT;
				errRollPitch_e[2] /= normdGPSdt_e*delT;
				
				//Rotate earth drift error back into body frame;
				rot_mult(Rbe, errRollPitch_e, errRollPitch_b, FALSE);
				
				correctGyroDriftDCM_flag=TRUE;
				memset(drft->accels_e_integrator, 0, sizeof(drft->accels_e_integrator)); //Reset integrator
			}
		}
	}
	
	float normOmegaScalar = sqrt(gyros[0]*gyros[0] + gyros[1]*gyros[1] + gyros[2]*gyros[2]);
	
	//In addition to calculating the roll-pitch-yaw error, we can yaw drift
	yaw_drift(drft->GPSV_old, Rbe, errYaw_b); //We're actually using new GPS data here, but it's already been stored in old by the previous function
	
	//Calculate gyro drift, based on all errors
	gyro_drift(gyros, errYaw_b, errRollPitch_b, normOmegaScalar, omegaCorrP, omegaCorrI);
	
	calibrate_gyros_high_speed(gyros, omegaCorrP, normOmegaScalar, glbl->gyroGain);

	if (correctGyroDriftDCM_flag || !correctGyroDriftDCM_flag)
	{
		//THIS DOES NOTHING, IT'S JUST TO FOOL THE COMPILER INTO THINKING THAT correctGyroDriftDCM_flag IS BEING USED, UNTIL I ACTUALLY PROGRAM THE CODE THAT USES IT
	}
	//	omega = omegaGyros + omegaCorrP + omegaCorrI
	gyros[0]+=omegaCorrP[0]+omegaCorrI[0];
	gyros[1]+=omegaCorrP[1]+omegaCorrI[1];
	gyros[2]+=omegaCorrP[2]+omegaCorrI[2];
}



void gyro_drift(float gyro[3], float errYaw_b[3], float errRollPitch_b[3], float normOmegaScalar, float *omegaCorrP, float *omegaCorrI)
{
	
	int kpyaw ;
	int kprollpitch ;
	
	// boost the KPs at high spin rate, to compensate for increased error due to calibration error
	// above 50 degrees/second, scale by rotation rate divided by 50
	
	if ( normOmegaScalar < ( 50.0f ))
	{
		kpyaw = KPYAW ;
		kprollpitch = KPROLLPITCH ;
	}
	else if ( normOmegaScalar < ( 500.0f ) )
	{
		kpyaw = ( KPYAW / 50.0f )*normOmegaScalar ;
		kprollpitch = ( KPROLLPITCH / 50.0f )*normOmegaScalar ;
	}
	else
	{
		kpyaw = ( int ) ( 10.0f * KPYAW ) ;
		kprollpitch = ( int ) ( 10.0f * KPROLLPITCH ) ;
	}

	omegaCorrP[0]=errRollPitch_b[0]*kprollpitch+errYaw_b[0]*kpyaw;
	omegaCorrP[1]=errRollPitch_b[1]*kprollpitch+errYaw_b[1]*kpyaw;
	omegaCorrP[2]=errRollPitch_b[2]*kprollpitch+errYaw_b[2]*kpyaw;
//	VectorScale( 3 , omegacorrP , errorYawplane , kpyaw ) ; // Scale gain = 2
//	VectorScale( 3 , errorRPScaled , errorRP , kprollpitch ) ; // Scale gain = 2
//	VectorAdd( 3 , omegacorrP , omegacorrP , errorRPScaled ) ;
	
	// turn off the offset integrator while spinning, it doesn't work in that case,
	// and it only causes trouble.
	
	if ( normOmegaScalar < MAXIMUM_SPIN_DCM_INTEGRAL )
	{       
		drft->gyros_b_integrator[0] += errRollPitch_b[0]*KIROLLPITCH;
		drft->gyros_b_integrator[1] += errRollPitch_b[1]*KIROLLPITCH;
		drft->gyros_b_integrator[2] += errRollPitch_b[2]*KIROLLPITCH;
		
		drft->gyros_b_integrator[0] += errYaw_b[0]*KIYAW;
		drft->gyros_b_integrator[1] += errYaw_b[1]*KIYAW;
		drft->gyros_b_integrator[2] += errYaw_b[2]*KIYAW;
	}
	
	omegaCorrI[0] = drft->gyros_b_integrator[0];
	omegaCorrI[1] = drft->gyros_b_integrator[1];
	omegaCorrI[2] = drft->gyros_b_integrator[2];
	
	return ;
}

#define GYRO_CALIB_TAU 10.0
#define MINIMUM_SPIN_RATE_GYRO_CALIB 50.0 // degrees/second
#define GGAIN 1
void calibrate_gyros_high_speed(float gyro[3], float omegaCorrP[3], float normOmegaScalar, float *ggain)
{
	float normOmegaVector[3]={gyro[0]/normOmegaScalar, gyro[1]/normOmegaScalar, gyro[2]/normOmegaScalar};	
	if ( normOmegaScalar > MINIMUM_SPIN_RATE_GYRO_CALIB )
	{
		int gain_change[3] ;
		//Calculate delta gain
		gain_change[0]=normOmegaVector[0] * omegaCorrP[0]/normOmegaScalar*( 0.025*GGAIN/GYRO_CALIB_TAU );
		gain_change[1]=normOmegaVector[1] * omegaCorrP[1]/normOmegaScalar*( 0.025*GGAIN/GYRO_CALIB_TAU );
		gain_change[2]=normOmegaVector[2] * omegaCorrP[2]/normOmegaScalar*( 0.025*GGAIN/GYRO_CALIB_TAU );
		
		//Update gains
		ggain[0]+=gain_change[0];
		ggain[1]+=gain_change[1];
		ggain[2]+=gain_change[2];
		
		//Saturate gains
		for (int i=0;i <3; i++){
			ggain[i]=ggain[i] <0.9? 0.9 : ggain[i];
			ggain[i]=ggain[i] >1.1? 1.1 : ggain[i];
		}
	}
	return ;
}

/*
 * Although yaw correction is done in horizontal plane, it is 
 *  computed in 3 dimensions, just in case we change our minds later.
 */

#define GPS_SPEED_MIN 5 // Minimum velocity in [m/s]
#define GPS_YAW_KP .1;
void yaw_drift(float gpsV[3], float Rbe[3][3], float *errYaw_b)
{
#if defined (PIOS_INCLUDE_GPS) || defined (PIOS_INCLUDE_MAGNETOMETER)
	
	errYaw_b[0] = errYaw_b[1] = errYaw_b[2] = 0; //Set to zero in case there are no yaw measurements

	//      Form the horizontal direction over ground based on rmat
	float horizDirOverGndRmat[3];

	//Define forward vector in body frame
	float tmpVec[3]={1,0,0};

	//Rotate forward vector into earth frame
	rot_mult(Rbe, tmpVec, horizDirOverGndRmat, TRUE);

	//Eliminate vertical component from vector
	horizDirOverGndRmat[2]=0;
 #if defined (PIOS_INCLUDE_GPS)
	if ( gpsV[0] > GPS_SPEED_MIN || gpsV[1] > GPS_SPEED_MIN)
	{
		float errorGPSYaw_e[3];
		float errorGPSYaw_b[3];
		float horizDirOverGndGPS[3]={gpsV[0], gpsV[1], 0};
		//      vector cross product to get the rotation error in ground frame
		CrossProduct(horizDirOverGndRmat, horizDirOverGndGPS, errorGPSYaw_e);
		//      convert to body frame:
		rot_mult(Rbe, errorGPSYaw_e, errorGPSYaw_b, FALSE);
		
		errYaw_b[0] += errorGPSYaw_b[0]*GPS_YAW_KP;
		errYaw_b[1] += errorGPSYaw_b[1]*GPS_YAW_KP;
		errYaw_b[2] += errorGPSYaw_b[2]*GPS_YAW_KP;
	}
	
 #endif	
	
 #if defined (PIOS_INCLUDE_MAGNETOMETER) //THIS PIOS DEFINE NOT CURRENTLY EXIST, BUT WE SHOULD ADD IT IN ORDER TO SUPPORT ALL MAGS, NOT JUST THE HMC5883
	float errorMagYaw_e[3];
	
	//      vector cross product to get the rotation error in ground frame
	CrossProduct(horizDirOverGndRmat, horizDirOverGndMag, errorMagYaw_e);
	//      convert to body frame:
	rot_mult(Rbe, errorMagYaw_e, errorMagYaw_b, FALSE);

	errYaw_b[0] += errorMagYaw_e[0]*MAG_YAW_KP;
	errYaw_b[1] += errorMagYaw_e[1]*MAG_YAW_KP;
	errYaw_b[2] += errorMagYaw_e[2]*MAG_YAW_KP;
 #endif
#endif	
}

/**
 * @}
 * @}
 */
