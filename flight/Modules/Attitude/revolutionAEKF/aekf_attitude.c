/**
 ******************************************************************************
 * @addtogroup OpenPilotModules OpenPilot Modules
 * @{
 * @addtogroup Attitude Copter Control Attitude Estimation
 * @brief Acquires sensor data and computes attitude estimate
 * Specifically updates the the @ref AttitudeActual "AttitudeActual" and @ref AttitudeRaw "AttitudeRaw" settings objects
 * @{
 *
 * @file       attitude.c
 * @author     The OpenPilot Team, http://www.openpilot.org Copyright (C) 2010.
 * @brief      Module to handle all comms to the AHRS on a periodic basis.
 *
 * @see        The GNU Public License (GPL) Version 3
 *
 ******************************************************************************/
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

/**
 * Input objects: None, takes sensor data via pios
 * Output objects: @ref AttitudeRaw @ref AttitudeActual
 *
 * This module computes an attitude estimate from the sensor data
 *
 * The module executes in its own thread.
 *
 * UAVObjects are automatically generated by the UAVObjectGenerator from
 * the object definition XML file.
 *
 * Modules have no API, all communication to other modules is done through UAVObjects.
 * However modules may use the API exposed by shared libraries.
 * See the OpenPilot wiki for more details.
 * http://www.openpilot.org/OpenPilot_Application_Architecture
 *
 */

 #include "pios.h"
 #include "attitude.h"
 #include "magnetometer.h"
 #include "accels.h"
 #include "gyros.h"
 #include "gyrosbias.h"
 #include "attitudeactual.h"
 #include "attitudesettings.h"
 #include "positionactual.h"
 #include "velocityactual.h"
 #include "gpsposition.h"
 #include "baroaltitude.h"
 #include "flightstatus.h"
 #include "homelocation.h"
 #include "CoordinateConversions.h"
 
// Private constants
#define STACK_SIZE_BYTES 5540
#define TASK_PRIORITY (tskIDLE_PRIORITY+3)
#define FAILSAFE_TIMEOUT_MS 10

#define F_PI 3.14159265358979323846f
#define PI_MOD(x) (fmod(x + F_PI, F_PI * 2) - F_PI)

// Private types

//---------------------------------------------------------------------------
// Things added for AEKF
void AEKFInit()
float g=9.803;
//---------------------------------------------------------------------------

// Private variables
static xTaskHandle sensorTaskHandle;
static xTaskHandle attitudeTaskHandle;

static xQueueHandle gyroQueue;
static xQueueHandle accelQueue;
static xQueueHandle magQueue;
static xQueueHandle baroQueue;
static xQueueHandle gpsQueue;
const uint32_t SENSOR_QUEUE_SIZE = 10;

// Private functions
static void SensorTask(void *parameters);
static void AttitudeTask(void *parameters);

static int32_t updateSensors();
static int32_t updateAttitudeComplimentary(bool first_run);
static int32_t updateAttitudeINSGPS(bool first_run);
static void settingsUpdatedCb(UAVObjEvent * objEv);

static float accelKi = 0;
static float accelKp = 0;
static float yawBiasRate = 0;
static float gyroGain = 0.42;
static int16_t accelbias[3];
static float R[3][3];
static int8_t rotate = 0;
static bool zero_during_arming = false;


/**
 * API for sensor fusion algorithms:
 * Configure(xQueueHandle gyro, xQueueHandle accel, xQueueHandle mag, xQueueHandle baro)
 *   Stores all the queues the algorithm will pull data from
 * FinalizeSensors() -- before saving the sensors modifies them based on internal state (gyro bias)
 * Update() -- queries queues and updates the attitude estiamte
 */


/**
 * Initialise the module.  Called before the start function
 * \returns 0 on success or -1 if initialisation failed
 */
int32_t AttitudeInitialize(void)
{
	AttitudeActualInitialize();
	AttitudeSettingsInitialize();
	PositionActualInitialize();
	VelocityActualInitialize();
	
	// Initialize this here while we aren't setting the homelocation in GPS
	HomeLocationInitialize();
	
	// Initialize quaternion
	AttitudeActualData attitude;
	AttitudeActualGet(&attitude);
	attitude.q1 = 1;
	attitude.q2 = 0;
	attitude.q3 = 0;
	attitude.q4 = 0;
	AttitudeActualSet(&attitude);
	
	// Cannot trust the values to init right above if BL runs
	GyrosBiasData gyrosBias;
	GyrosBiasGet(&gyrosBias);
	gyrosBias.x = 0;
	gyrosBias.y = 0;
	gyrosBias.z = 0;
	GyrosBiasSet(&gyrosBias);
	
	for(uint8_t i = 0; i < 3; i++)
		for(uint8_t j = 0; j < 3; j++)
			R[i][j] = 0;
	
	AttitudeSettingsConnectCallback(&settingsUpdatedCb);
	
	return 0;
}

/**
 * Start the task.  Expects all objects to be initialized by this point.
 * \returns 0 on success or -1 if initialisation failed
 */
int32_t AttitudeStart(void)
{
	// Create the queues for the sensors
	gyroQueue = xQueueCreate(1, sizeof(UAVObjEvent));
	accelQueue = xQueueCreate(1, sizeof(UAVObjEvent));
	magQueue = xQueueCreate(1, sizeof(UAVObjEvent));
	baroQueue = xQueueCreate(1, sizeof(UAVObjEvent));
	gpsQueue = xQueueCreate(1, sizeof(UAVObjEvent));
	
	// Start main task
	xTaskCreate(AttitudeTask, (signed char *)"Attitude", STACK_SIZE_BYTES/4, NULL, TASK_PRIORITY, &attitudeTaskHandle);
	TaskMonitorAdd(TASKINFO_RUNNING_ATTITUDE, attitudeTaskHandle);
	PIOS_WDG_RegisterFlag(PIOS_WDG_ATTITUDE);
	
	GyrosConnectQueue(gyroQueue);
	AccelsConnectQueue(accelQueue);
	MagnetometerConnectQueue(magQueue);
	BaroAltitudeConnectQueue(baroQueue);
	GPSPositionConnectQueue(gpsQueue);
	
	return 0;
}

MODULE_INITCALL(AttitudeInitialize, AttitudeStart)

/**
 * Module thread, should not return.
 */
static void AttitudeTask(void *parameters)
{
	AlarmsClear(SYSTEMALARMS_ALARM_ATTITUDE);
	
	// Force settings update to make sure rotation loaded
	settingsUpdatedCb(AttitudeSettingsHandle());
	
	bool first_run = true;
	
	// Wait for all the sensors be to read
	vTaskDelay(100);
	
	// Main task loop
	while (1) {
		
		// This  function blocks on data queue
		if(0){ 
			updateAttitudeComplimentary(first_run);
		}
		else if(0){
			updateAttitudeINSGPS(first_run);
		}
		else{
			updateAttitudeAEKF(first_run);
		}
		
		if (first_run)
			first_run = false;
		
		PIOS_WDG_UpdateFlag(PIOS_WDG_ATTITUDE);
	}
}


#include "aekf.h"
int32_t ins_failed = 0;
extern struct NavStruct Nav;
static int32_t updateAttitudeINSGPS(bool first_run)
{
	UAVObjEvent ev;
	GyrosData gyrosData;
	AccelsData accelsData;
	MagnetometerData magData;
	BaroAltitudeData baroData;
	
	static uint32_t aekf_last_time = 0;
	
	static bool inited;
	if (first_run)
		inited = false;
	
	// Wait until the gyro and accel object is updated, if a timeout then go to failsafe
	if ( (xQueueReceive(gyroQueue, &ev, 10 / portTICK_RATE_MS) != pdTRUE) ||
		(xQueueReceive(accelQueue, &ev, 10 / portTICK_RATE_MS) != pdTRUE) )
	{
		AlarmsSet(SYSTEMALARMS_ALARM_ATTITUDE,SYSTEMALARMS_ALARM_WARNING);
		return -1;
	}
	
	// Get most recent data
	// TODO: Acquire all data in a queue
	GyrosGet(&gyrosData);
	AccelsGet(&accelsData);
	MagnetometerGet(&magData);
	BaroAltitudeGet(&baroData);
	
	bool mag_updated;
	bool baro_updated;
	bool gps_updated;
	
	if (inited) {
		mag_updated = 0;
		baro_updated = 0;
	}
	
	gps_updated |= xQueueReceive(gpsQueue, &ev, 0 / portTICK_RATE_MS) == pdTRUE;
	baro_updated |= xQueueReceive(baroQueue, &ev, 0 / portTICK_RATE_MS) == pdTRUE;
	acc_updated |= xQueueReceive(accQueue, &ev, 0 / portTICK_RATE_MS) == pdTRUE;
	mag_updated |= xQueueReceive(magQueue, &ev, 0 / portTICK_RATE_MS) == pdTRUE;
	gyro_updated |= xQueueReceive(gyroQueue, &ev, 0 / portTICK_RATE_MS) == pdTRUE;
	
	if (!inited && (!mag_updated || !baro_updated || !gps_updated)) {
		// Don't initialize until all sensors are read
		return -1;
	} 
	else if (!inited )
	{//Initialize the sensors and structure
		inited = true;
		
		float Rbe[3][3], q[4], accels[3], rpy[3], mag; //Rotation Body-->Earth, quaternions, accelerometers, gyros, and magnetometer
		float ge[3]={0.0f,0.0f,g}; //Gravitational vector
		float zeros[3]={0.0f,0.0f,0.0f}; //???
		float Pdiag[16]={25.0f,25.0f,25.0f,5.0f,5.0f,5.0f,1e-5f,1e-5f,1e-5f,1e-5f,1e-5f,1e-5f,1e-5f,1e-4f,1e-4f,1e-4f}; //Initialize P matrix
		float vel[3], NED[3]; //Create velocity and position vectors
		bool using_mags, using_gps;
		
		AEKFInit();
		
		//Set home location (for GPS)
		HomeLocationData home;
		HomeLocationGet(&home);
		
		//Get GPS position
		GPSPositionData gpsPosition;
		GPSPositionGet(&gpsPosition);
		
		vel[0] = gpsPosition.Groundspeed * cosf(gpsPosition.Heading * F_PI / 180.0f);
		vel[1] = gpsPosition.Groundspeed * sinf(gpsPosition.Heading * F_PI / 180.0f);
		vel[2] = 0;
		
		// convert from cm back to meters
		float LLA[3] = {(float) gpsPosition.Latitude / 1e7f, (float) gpsPosition.Longitude / 1e7f, (float) (gpsPosition.GeoidSeparation + gpsPosition.Altitude)};
		// put in local NED frame
		float ECEF[3] = {(float) (home.ECEF[0] / 100.0f), (float) (home.ECEF[1] / 100.0f), (float) (home.ECEF[2] / 100.0f)};
		LLA2Base(LLA, ECEF, (float (*)[3]) home.RNE, NED);
		
		RotFrom2Vectors(&accelsData.x, ge, &magData.x, home.Be, Rbe);
		R2Quaternion(Rbe,q);
		INSSetState(NED, vel, q, &gyrosData.x, zeros);
		INSSetGyroBias(&gyrosData.x);
		INSResetP(Pdiag);
		
		aekf_last_time = PIOS_DELAY_GetRaw();	
		return 0;
	}
	
	// Perform the update
	static uint32_t updated_without_gps = 0;
	
	float zeros[3] = {0, 0, 0};
	uint16_t sensors = 0;
	float dT;
	
	//Calculate dT
	dT = PIOS_DELAY_DiffuS(aekf_last_time) / 1.0e6f;
	aekf_last_time = PIOS_DELAY_GetRaw();
	
	// This should only happen at start up or at mode switches
	//HOW SHOULD I TREAT THIS? IS THIS SOMETHING IMPORTANT, SINCE I'LL BE RUNNING AT DRASTICALLY SLOWER SPEEDS?
	{
		if(dT > 0.01f)
			dT = 0.01f;
		else if(dT <= 0.001f)
			dT = 0.001f;
	}	
	
	GyrosBiasData gyrosBias;
	GyrosBiasGet(&gyrosBias);
	
	float gyros[3] = {(gyrosData.x + gyrosBias.x) * F_PI / 180.0f, 
		(gyrosData.y + gyrosBias.y) * F_PI / 180.0f, 
		(gyrosData.z + gyrosBias.z) * F_PI / 180.0f};
	
//Perform predictions
//=========================
	//Calculate the high-gain system covariance matrix
	aekf_calculate_Delta_Q_HG(&Delta_Q_HG, theta_hg);
	for (int i=0; i < NX ; i++){
		Qg.fl[i][i]=theta_hg*Delta_Q_HG.fl[i]*Qc.fl[i][i]*Delta_Q_HG.fl[i];
	}
	
	//Integrate
	integ_aekf_rk4(&xkm, &Pkm, &xk_hat, &Pk_hat, &Qg, &F, &T, &mag, theta_hg, delT);
	
	// WHAT SHOULD I DO WITH THIS DATA?
	{
		// Copy the attitude into the UAVO
		stateActualData state;
		StateActualGet(&state);
		attitude.q1 = Nav.q[0];
		attitude.q2 = Nav.q[1];
		attitude.q3 = Nav.q[2];
		attitude.q4 = Nav.q[3];
		Quaternion2RPY(&attitude.q1,&attitude.Roll);
		AttitudeActualSet(&attitude);
	
		// Copy the gyro bias into the UAVO
		gyrosBias.x = Nav.gyro_bias[0];
		gyrosBias.y = Nav.gyro_bias[1];
		gyrosBias.z = Nav.gyro_bias[2];
		GyrosBiasSet(&gyrosBias);
	}
	
	//THIS STRUCTURE IS TOO INFLEXIBLE. IT MAKES IT DIFFICULT TO ADD ADDITIONAL SENSORS, OR USE LESS OF THEM. IT HIDES THE PHYSICAL TRUTH
	if(baro_updated)
		sensors |= BARO_SENSOR;
	if(acc_updated)
		sensors |= ACC_SENSOR;
	if(mag_updated)
		sensors |= MAG_SENSORS;
	if(gyro_updated)
		sensors |= GYRO_SENSOR;
	
	float NED[3] = {0,0,0};
	float vel[3] = {0,0,0};
	
	if(gps_updated)
	{
		sensors = HORIZ_SENSORS | VERT_SENSORS; //IS THIS AN ERROR, TO HAVE AN ASSIGNMENT, INSTEAD OF AN `OR`?
		GPSPositionData gpsPosition;
		GPSPositionGet(&gpsPosition);
		
		vel[0] = gpsPosition.Groundspeed * cosf(gpsPosition.Heading * F_PI / 180.0f);
		vel[1] = gpsPosition.Groundspeed * sinf(gpsPosition.Heading * F_PI / 180.0f);
		vel[2] = 0;
		
		HomeLocationData home;
		HomeLocationGet(&home);
		
		// convert from cm back to meters
		float LLA[3] = {(float) gpsPosition.Latitude / 1e7f, (float) gpsPosition.Longitude / 1e7f, (float) (gpsPosition.GeoidSeparation + gpsPosition.Altitude)};
		// put in local NED frame
		float ECEF[3] = {(float) (home.ECEF[0] / 100.0f), (float) (home.ECEF[1] / 100.0f), (float) (home.ECEF[2] / 100.0f)};
		LLA2Base(LLA, ECEF, (float (*)[3]) home.RNE, NED);
	}
	
	/*
	 * TODO: Need to add a general sanity check for all the inputs to make sure they're kosher
	 * although probably should occur within INS itself
	 */
	INSCorrection(&magData.x, NED, vel, baroData.Altitude, sensors);
	
	// Copy the position and velocity into the UAVO
	PositionActualData positionActual;
	PositionActualGet(&positionActual);
	positionActual.North = Nav.Pos[0];
	positionActual.East = Nav.Pos[1];
	positionActual.Down = Nav.Pos[2];
	PositionActualSet(&positionActual);
	
	VelocityActualData velocityActual;
	VelocityActualGet(&velocityActual);
	velocityActual.North = Nav.Vel[0];
	velocityActual.East = Nav.Vel[1];
	velocityActual.Down = Nav.Vel[2];
	VelocityActualSet(&velocityActual);
	
	
	if(fabs(Nav.gyro_bias[0]) > 0.1f || fabs(Nav.gyro_bias[1]) > 0.1f || fabs(Nav.gyro_bias[2]) > 0.1f) {
		float zeros[3] = {0.0f,0.0f,0.0f};
		INSSetGyroBias(zeros);
	}
	
}

static void settingsUpdatedCb(UAVObjEvent * objEv) 
{
	AttitudeSettingsData attitudeSettings;
	AttitudeSettingsGet(&attitudeSettings);
	
	
	accelKp = attitudeSettings.AccelKp;
	accelKi = attitudeSettings.AccelKi;
	yawBiasRate = attitudeSettings.YawBiasRate;
	gyroGain = attitudeSettings.GyroGain;
	
	zero_during_arming = attitudeSettings.ZeroDuringArming == ATTITUDESETTINGS_ZERODURINGARMING_TRUE;
	
	accelbias[0] = attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_X];
	accelbias[1] = attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_Y];
	accelbias[2] = attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_Z];
	
	GyrosBiasData gyrosBias;
	GyrosBiasGet(&gyrosBias);
	gyrosBias.x = attitudeSettings.GyroBias[ATTITUDESETTINGS_GYROBIAS_X] / 100.0f;
	gyrosBias.y = attitudeSettings.GyroBias[ATTITUDESETTINGS_GYROBIAS_Y] / 100.0f;
	gyrosBias.z = attitudeSettings.GyroBias[ATTITUDESETTINGS_GYROBIAS_Z] / 100.0f;
	GyrosBiasSet(&gyrosBias);
	
	// Indicates not to expend cycles on rotation
	if(attitudeSettings.BoardRotation[0] == 0 && attitudeSettings.BoardRotation[1] == 0 &&
	   attitudeSettings.BoardRotation[2] == 0) {
		rotate = 0;
		
		// Shouldn't be used but to be safe
		float rotationQuat[4] = {1,0,0,0};
		Quaternion2R(rotationQuat, R);
	} else {
		float rotationQuat[4];
		const float rpy[3] = {attitudeSettings.BoardRotation[ATTITUDESETTINGS_BOARDROTATION_ROLL],
			attitudeSettings.BoardRotation[ATTITUDESETTINGS_BOARDROTATION_PITCH],
			attitudeSettings.BoardRotation[ATTITUDESETTINGS_BOARDROTATION_YAW]};
		RPY2Quaternion(rpy, rotationQuat);
		Quaternion2R(rotationQuat, R);
		rotate = 1;
	}
}
/**
 * @}
 * @}
 */
