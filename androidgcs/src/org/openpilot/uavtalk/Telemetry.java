/**
 ******************************************************************************
 * @file       Telemetry.java
 * @author     The OpenPilot Team, http://www.openpilot.org Copyright (C) 2012.
 * @brief      Port of Telemetry.cpp from the GCS.  Handles transactions on the
 *             UAVTalk channel.
 * @see        The GNU Public License (GPL) Version 3
 *
 *****************************************************************************/
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package org.openpilot.uavtalk;

import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Observable;
import java.util.Observer;
import java.util.Queue;
import java.util.Timer;
import java.util.TimerTask;

import android.util.Log;

public class Telemetry {

	private final String TAG = "Telemetry";
	public static int LOGLEVEL = 1;
	public static boolean WARN = LOGLEVEL > 2;
	public static boolean DEBUG = LOGLEVEL > 1;
	public static boolean ERROR = LOGLEVEL > 0;
    public class TelemetryStats {
        public int txBytes;
        public int rxBytes;
        public int txObjectBytes;
        public int rxObjectBytes;
        public int rxObjects;
        public int txObjects;
        public int txErrors;
        public int rxErrors;
        public int txRetries;
    } ;

    class ObjectTimeInfo {
        UAVObject obj;
        int updatePeriodMs; /** Update period in ms or 0 if no periodic updates are needed */
        int timeToNextUpdateMs; /** Time delay to the next update */
    };

    class ObjectQueueInfo {
        UAVObject obj;
        int event;
        boolean allInstances;

        @Override
		public boolean equals(Object e) {
        	try {
        		ObjectQueueInfo o = (ObjectQueueInfo) e;
        		return o.obj.getObjID() == obj.getObjID() &&  o.event == event && o.allInstances == allInstances;
        	} catch (Exception err) {

        	};
        	return false;
        }
    };

    class ObjectTransactionInfo {
        UAVObject obj;
        boolean allInstances;
        boolean objRequest;
        int retriesRemaining;
        boolean acked;
    } ;

    /**
     * Events generated by objects.  Not enum because used in mask.
     */
    private static final int EV_UNPACKED = 0x01;       /** Object data updated by unpacking */
    private static final int EV_UPDATED = 0x02;        /** Object data updated by changing the data structure */
    private static final int EV_UPDATED_MANUAL = 0x04; /** Object update event manually generated */
    private static final int EV_UPDATE_REQ = 0x08;     /** Request to update object data */

    /**
     * Constructor
     */
    public Telemetry(UAVTalk utalkIn, UAVObjectManager objMngr)
    {
        this.utalk = utalkIn;
        this.objMngr = objMngr;

        // Process all objects in the list
        List< List<UAVObject> > objs = objMngr.getObjects();
        ListIterator<List<UAVObject>> li = objs.listIterator();
        while(li.hasNext())
        	registerObject(li.next().get(0)); // we only need to register one instance per object type

        // Listen to new object creations
        objMngr.addNewInstanceObserver(new Observer() {
			@Override
			public void update(Observable observable, Object data) {
        		newInstance((UAVObject) data);
			}
        });
        objMngr.addNewObjectObserver(new Observer() {
			@Override
			public void update(Observable observable, Object data) {
        		newObject((UAVObject) data);
        	}
        });

        // Listen to transaction completions from uavtalk
        utalk.setOnTransactionCompletedListener(
        		utalk.new OnTransactionCompletedListener() {
			@Override
			void TransactionSucceeded(UAVObject data) {
	        	try {
					transactionCompleted(data, true);
				} catch (IOException e) {
					// Disconnect when stream fails
					utalk.setOnTransactionCompletedListener(null);
				}
	        }
			@Override
			void TransactionFailed(UAVObject data) {
	        	try {
	        		if (DEBUG) Log.d(TAG, "TransactionFailed(" + data.getName() + ")");

					transactionCompleted(data, false);
				} catch (IOException e) {
					// Disconnect when stream fails
					utalk.setOnTransactionCompletedListener(null);
				}
	        }

        });

        // Get GCS stats object
        gcsStatsObj = objMngr.getObject("GCSTelemetryStats");

        // Setup transaction timer
        transPending = false;
        // Setup and start the periodic timer
        timeToNextUpdateMs = 0;
        updateTimerSetPeriod(1000);
        // Setup and start the stats timer
        txErrors = 0;
        txRetries = 0;
    }

    synchronized void transTimerSetPeriod(int periodMs) {
    	if(transTimerTask != null)
    		transTimerTask.cancel();

    	if(transTimer != null)
    		transTimer.purge();

   		transTimer = new Timer();

        transTimerTask = new TimerTask() {
			@Override
			public void run() {
				try {
					transactionTimeout();
				} catch (IOException e) {
					cancel();
				}
			}
        };
        transTimer.schedule(transTimerTask, periodMs, periodMs);
    }

    synchronized void updateTimerSetPeriod(int periodMs) {
    	if (updateTimer != null) {
    		updateTimer.cancel();
    		updateTimer = null;
    	}
    	if (updateTimerTask != null) {
    		updateTimerTask.cancel();
    		updateTimerTask = null;
    	}
        updateTimer = new Timer();
        updateTimerTask = new TimerTask() {
			@Override
			public void run() {
				try {
					processPeriodicUpdates();
				} catch (IOException e) {
					updateTimerTask.cancel();
					updateTimer.cancel();
				}
			}
        };
        updateTimer.schedule(updateTimerTask, periodMs, periodMs);

    }

    /**
     * Register a new object for periodic updates (if enabled)
     */
    private synchronized void registerObject(UAVObject obj)
    {
        // Setup object for periodic updates
        addObject(obj);

        // Setup object for telemetry updates
        updateObject(obj);
    }

    /**
     * Add an object in the list used for periodic updates
     */
    private synchronized void addObject(UAVObject obj)
    {
        // Check if object type is already in the list
    	ListIterator<ObjectTimeInfo> li = objList.listIterator();
    	while(li.hasNext()) {
    		ObjectTimeInfo n = li.next();
    		if( n.obj.getObjID() == obj.getObjID() )
            {
                // Object type (not instance!) is already in the list, do nothing
                return;
            }
        }

        // If this point is reached, then the object type is new, let's add it
        ObjectTimeInfo timeInfo = new ObjectTimeInfo();
        timeInfo.obj = obj;
        timeInfo.timeToNextUpdateMs = 0;
        timeInfo.updatePeriodMs = 0;
        objList.add(timeInfo);
    }

    /**
     * Update the object's timers
     */
    private synchronized void setUpdatePeriod(UAVObject obj, int periodMs)
    {
        // Find object type (not instance!) and update its period
    	ListIterator<ObjectTimeInfo> li = objList.listIterator();
    	while(li.hasNext()) {
    		ObjectTimeInfo n = li.next();
            if ( n.obj.getObjID() == obj.getObjID() )
            {
                n.updatePeriodMs = periodMs;
                n.timeToNextUpdateMs = (int) (periodMs * (new java.util.Random()).nextDouble()); // avoid bunching of updates
            }
        }
    }

    final Observer unpackedObserver = new Observer() {
		@Override
		public void update(Observable observable, Object data) {
    		try {
    			enqueueObjectUpdates((UAVObject) data, EV_UNPACKED, false, true);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
    	}
	};

	final Observer updatedAutoObserver = new Observer() {
		@Override
		public void update(Observable observable, Object data) {
			try {
				enqueueObjectUpdates((UAVObject) data, EV_UPDATED, false, true);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
    	}
	};

	final Observer updatedManualObserver = new Observer() {
		@Override
		public void update(Observable observable, Object data) {
			try {
				enqueueObjectUpdates((UAVObject) data, EV_UPDATED_MANUAL, false, true);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
    	}
	};

	final Observer updatedRequestedObserver = new Observer() {
		@Override
		public void update(Observable observable, Object data) {
			try {
				enqueueObjectUpdates((UAVObject) data, EV_UPDATE_REQ, false, true);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
    	}
	};

    /**
     * Connect to all instances of an object depending on the event mask specified
     */
    private synchronized void connectToObjectInstances(UAVObject obj, int eventMask)
    {
        List<UAVObject> objs = objMngr.getObjectInstances(obj.getObjID());
        ListIterator<UAVObject> li = objs.listIterator();
        while(li.hasNext())
        {
        	obj = li.next();

            // Disconnect all previous observers from telemetry.  This is imortant as this can
        	// be called multiple times
        	obj.removeUnpackedObserver(unpackedObserver);
        	obj.removeUpdatedAutoObserver(updatedAutoObserver);
        	obj.removeUpdatedManualObserver(updatedManualObserver);
        	obj.removeUpdateRequestedObserver(updatedRequestedObserver);

            // Connect only the selected events
            if ( (eventMask&EV_UNPACKED) != 0)
            	obj.addUnpackedObserver(unpackedObserver);
            if ( (eventMask&EV_UPDATED) != 0)
            	obj.addUpdatedAutoObserver(updatedAutoObserver);
            if ( (eventMask&EV_UPDATED_MANUAL) != 0)
            	obj.addUpdatedManualObserver(updatedManualObserver);
            if ( (eventMask&EV_UPDATE_REQ) != 0)
            	obj.addUpdateRequestedObserver(updatedRequestedObserver);
        }
    }

    /**
     * Update an object based on its metadata properties
     */
    private synchronized void updateObject(UAVObject obj)
    {
        // Get metadata
        UAVObject.Metadata metadata = obj.getMetadata();

        // Setup object depending on update mode
        int eventMask;
        if ( metadata.GetGcsTelemetryUpdateMode() == UAVObject.UpdateMode.UPDATEMODE_PERIODIC )
        {
            // Set update period
            setUpdatePeriod(obj, metadata.gcsTelemetryUpdatePeriod);
            // Connect signals for all instances
            eventMask = EV_UPDATED_MANUAL | EV_UPDATE_REQ;
            if(obj.isMetadata())
                eventMask |= EV_UNPACKED; // we also need to act on remote updates (unpack events)

            connectToObjectInstances(obj, eventMask);
        }
        else if ( metadata.GetGcsTelemetryUpdateMode() == UAVObject.UpdateMode.UPDATEMODE_ONCHANGE )
        {
            // Set update period
            setUpdatePeriod(obj, 0);
            // Connect signals for all instances
            eventMask = EV_UPDATED | EV_UPDATED_MANUAL | EV_UPDATE_REQ;
            if(obj.isMetadata())
                eventMask |= EV_UNPACKED; // we also need to act on remote updates (unpack events)

            connectToObjectInstances(obj, eventMask);
        }
        else if ( metadata.GetGcsTelemetryUpdateMode() == UAVObject.UpdateMode.UPDATEMODE_THROTTLED )
        {
        	// TODO
        }
        else if ( metadata.GetGcsTelemetryUpdateMode() == UAVObject.UpdateMode.UPDATEMODE_MANUAL )
        {
            // Set update period
            setUpdatePeriod(obj, 0);
            // Connect signals for all instances
            eventMask = EV_UPDATED_MANUAL | EV_UPDATE_REQ;
            if(obj.isMetadata())
                eventMask |= EV_UNPACKED; // we also need to act on remote updates (unpack events)

            connectToObjectInstances(obj, eventMask);
        }
    }

    /**
     * Called when a transaction is successfully completed (uavtalk event)
     * @throws IOException
     */
    private synchronized void transactionCompleted(UAVObject obj, boolean result) throws IOException
    {
    	if (DEBUG) Log.d(TAG,"UAVTalk transactionCompleted");
        // Check if there is a pending transaction and the objects match
        if ( transPending && transInfo.obj.getObjID() == obj.getObjID() )
        {
        	if (DEBUG) Log.d(TAG,"Telemetry: transaction completed for " + obj.getName());
            // Complete transaction
        	transTimer.cancel();
            transPending = false;

            //Send signal
            obj.transactionCompleted(result);
            // Process new object updates from queue
            processObjectQueue();
        } else
        {
        	if (ERROR) Log.e(TAG,"Error: received a transaction completed when did not expect it.");
        	transPending = false;
        }
    }

    /**
     * Called when a transaction is not completed within the timeout period (timer event)
     * @throws IOException
     */
    private synchronized void transactionTimeout() throws IOException
    {
    	if (DEBUG) Log.d(TAG,"Telemetry: transaction timeout.");
        transTimer.cancel();
        // Proceed only if there is a pending transaction
        if ( transPending )
        {
            // Check if more retries are pending
            if (transInfo.retriesRemaining > 0)
            {
                --transInfo.retriesRemaining;
                processObjectTransaction();
                ++txRetries;
            }
            else
            {
            	if (ERROR) Log.e(TAG, "Transaction failed for: " + transInfo.obj.getName());

                // Terminate transaction.  This triggers UAVTalk to send a transaction
            	// failed signal which will make the next queue entry be processed
            	// Note this is UAVTalk listener TransactionFailed function and not the
            	// object specific transaction failed.
                utalk.cancelPendingTransaction(transInfo.obj);
                ++txErrors;
            }
        }
    }

    /**
     * Start an object transaction with UAVTalk, all information is stored in transInfo
     * @throws IOException
     */
    private synchronized void processObjectTransaction() throws IOException
    {
        if (transPending)
        {
        	if (DEBUG) Log.d(TAG, "Process Object transaction for " + transInfo.obj.getName());
            // Initiate transaction
            if (transInfo.objRequest)
            {
                utalk.sendObjectRequest(transInfo.obj, transInfo.allInstances);
            }
            else
            {
                utalk.sendObject(transInfo.obj, transInfo.acked, transInfo.allInstances);
            }
            // Start timer if a response is expected
            if ( transInfo.objRequest || transInfo.acked )
            {
            	transTimerSetPeriod(REQ_TIMEOUT_MS);
            }
            else
            {
            	transTimer.cancel();
                transPending = false;
            }
        } else
        {
        	if (ERROR) Log.e(TAG,"Error: inside of processObjectTransaction with no transPending");
        }
    }

    /**
     * Enqueue the event received from an object.  This is the main method that handles all the callbacks
     * from UAVObjects (due to updates, or update requests)
     */
    private synchronized void enqueueObjectUpdates(UAVObject obj, int event, boolean allInstances, boolean priority) throws IOException
    {
        // Push event into queue
    	if (DEBUG) Log.d(TAG, "Push event into queue for obj " + obj.getName() + " event " + event);
    	if(event == 8 && obj.getName().compareTo("GCSTelemetryStats") == 0)
    		Thread.dumpStack();
        ObjectQueueInfo objInfo = new ObjectQueueInfo();
        objInfo.obj = obj;
        objInfo.event = event;
        objInfo.allInstances = allInstances;
        if (priority)
        {
        	// Only enqueue if an identical transaction does not already exist
        	if(!objPriorityQueue.contains(objInfo)) {
        		if ( objPriorityQueue.size() < MAX_QUEUE_SIZE )
        		{
        			objPriorityQueue.add(objInfo);
        		}
        		else
        		{
        			++txErrors;
        			obj.transactionCompleted(false);
        			Log.w(TAG,"Telemetry: priority event queue is full, event lost " + obj.getName());
        		}
        	}
        }
        else
        {
        	// Only enqueue if an identical transaction does not already exist
        	if(!objQueue.contains(objInfo)) {
        		if ( objQueue.size() < MAX_QUEUE_SIZE )
        		{
        			objQueue.add(objInfo);
        		}
        		else
        		{
        			++txErrors;
        			obj.transactionCompleted(false);
        		}
        	}
        }

        // If there is no transaction in progress then process event
        if (!transPending)
        {
            processObjectQueue();
        }
    }

    /**
     * Process events from the object queue
     * @throws IOException
     */
    private synchronized void processObjectQueue() throws IOException
    {
      	if (DEBUG) Log.d(TAG, "Process object queue - Depth " + objQueue.size() + " priority " + objPriorityQueue.size());

        // Don nothing if a transaction is already in progress (should not happen)
        if (transPending)
        {
        	if (WARN) Log.e(TAG,"Dequeue while a transaction pending");
            return;
        }

        // Get object information from queue (first the priority and then the regular queue)
        ObjectQueueInfo objInfo;
        if ( !objPriorityQueue.isEmpty() )
        {
            objInfo = objPriorityQueue.remove();
        }
        else if ( !objQueue.isEmpty() )
        {
            objInfo = objQueue.remove();
        }
        else
        {
            return;
        }

        // Check if a connection has been established, only process GCSTelemetryStats updates
        // (used to establish the connection)
        gcsStatsObj = objMngr.getObject("GCSTelemetryStats");
        if ( ((String) gcsStatsObj.getField("Status").getValue()).compareTo("Connected") != 0 )
        {
            objQueue.clear();
            if ( objInfo.obj.getObjID() != objMngr.getObject("GCSTelemetryStats").getObjID() )
            {
            	if (DEBUG) Log.d(TAG,"transactionCompleted(false) due to receiving object not GCSTelemetryStats while not connected.");
                objInfo.obj.transactionCompleted(false);
                return;
            }
        }

        // Setup transaction (skip if unpack event)
        if ( objInfo.event != EV_UNPACKED )
        {
            UAVObject.Metadata metadata = objInfo.obj.getMetadata();
            transInfo.obj = objInfo.obj;
            transInfo.allInstances = objInfo.allInstances;
            transInfo.retriesRemaining = MAX_RETRIES;
            transInfo.acked = metadata.GetGcsTelemetryAcked();
            if ( objInfo.event == EV_UPDATED || objInfo.event == EV_UPDATED_MANUAL )
            {
                transInfo.objRequest = false;
            }
            else if ( objInfo.event == EV_UPDATE_REQ )
            {
                transInfo.objRequest = true;
            }
            // Start transaction
            transPending = true;
            processObjectTransaction();
        } else
        {
//            qDebug() << QString("Process object queue: this is an unpack event for %1").arg(objInfo.obj->getName());
        }

        // If this is a metaobject then make necessary telemetry updates
        if (objInfo.obj.isMetadata())
        {
        	UAVMetaObject metaobj = (UAVMetaObject) objInfo.obj;
            updateObject( metaobj.getParentObject() );
        }

        // The fact we received an unpacked event does not mean that
        // we do not have additional objects still in the queue,
        // so we have to reschedule queue processing to make sure they are not
        // stuck:
        if ( objInfo.event == EV_UNPACKED && !transPending)
            processObjectQueue();

    }

    /**
     * Check is any objects are pending for periodic updates
     * TODO: Clean-up
     * @throws IOException
     */
    private synchronized void processPeriodicUpdates() throws IOException
    {

    	if (DEBUG) Log.d(TAG, "processPeriodicUpdates()");
        // Stop timer
    	updateTimer.cancel();

        // Iterate through each object and update its timer, if zero then transmit object.
        // Also calculate smallest delay to next update (will be used for setting timeToNextUpdateMs)
        int minDelay = MAX_UPDATE_PERIOD_MS;
        ObjectTimeInfo objinfo;
        int elapsedMs = 0;
        long startTime;
        int offset;
        ListIterator<ObjectTimeInfo> li = objList.listIterator();
        while(li.hasNext())
        {
            objinfo = li.next();
            // If object is configured for periodic updates
            if (objinfo.updatePeriodMs > 0)
            {
                objinfo.timeToNextUpdateMs -= timeToNextUpdateMs;
                // Check if time for the next update
                if (objinfo.timeToNextUpdateMs <= 0)
                {
                    // Reset timer
                    offset = (-objinfo.timeToNextUpdateMs) % objinfo.updatePeriodMs;
                    objinfo.timeToNextUpdateMs = objinfo.updatePeriodMs - offset;
                    // Send object
                    startTime = System.currentTimeMillis();
                    enqueueObjectUpdates(objinfo.obj, EV_UPDATED_MANUAL, true, false);
                    elapsedMs = (int) (System.currentTimeMillis() - startTime);
                    // Update timeToNextUpdateMs with the elapsed delay of sending the object;
                    timeToNextUpdateMs += elapsedMs;
                }
                // Update minimum delay
                if (objinfo.timeToNextUpdateMs < minDelay)
                {
                    minDelay = objinfo.timeToNextUpdateMs;
                }
            }
        }

        // Check if delay for the next update is too short
        if (minDelay < MIN_UPDATE_PERIOD_MS)
        {
            minDelay = MIN_UPDATE_PERIOD_MS;
        }

        // Done
        timeToNextUpdateMs = minDelay;

        // Restart timer
        updateTimerSetPeriod(timeToNextUpdateMs);
    }

    public TelemetryStats getStats()
    {
        // Get UAVTalk stats
        UAVTalk.ComStats utalkStats = utalk.getStats();

        // Update stats
        TelemetryStats stats = new TelemetryStats();
        stats.txBytes = utalkStats.txBytes;
        stats.rxBytes = utalkStats.rxBytes;
        stats.txObjectBytes = utalkStats.txObjectBytes;
        stats.rxObjectBytes = utalkStats.rxObjectBytes;
        stats.rxObjects = utalkStats.rxObjects;
        stats.txObjects = utalkStats.txObjects;
        stats.txErrors = utalkStats.txErrors + txErrors;
        stats.rxErrors = utalkStats.rxErrors;
        stats.txRetries = txRetries;

        // Done
        return stats;
    }

    public synchronized void resetStats()
    {
        utalk.resetStats();
        txErrors = 0;
        txRetries = 0;
    }


    private void newObject(UAVObject obj)
    {
        registerObject(obj);
    }

    private synchronized void newInstance(UAVObject obj)
    {
        registerObject(obj);
    }

    /**
     * Stop all the telemetry timers
     */
    public void stopTelemetry()
    {
    	if (updateTimerTask != null)
    		updateTimerTask.cancel();
    	updateTimerTask = null;
    	if (updateTimer != null)
    		updateTimer.cancel();
    	updateTimer = null;
    	if (transTimerTask != null)
    		transTimerTask.cancel();
    	transTimerTask = null;
    	if (transTimer != null)
    		transTimer.cancel();
    	transTimer = null;
    }

	/**
	 * Private variables
	 */
    private final UAVObjectManager objMngr;
    private final UAVTalk utalk;
    private UAVObject gcsStatsObj;
    private final List<ObjectTimeInfo> objList = new ArrayList<ObjectTimeInfo>();
    private final Queue<ObjectQueueInfo> objQueue = new LinkedList<ObjectQueueInfo>();
    private final Queue<ObjectQueueInfo> objPriorityQueue = new LinkedList<ObjectQueueInfo>();
    private final ObjectTransactionInfo transInfo = new ObjectTransactionInfo();
    private boolean transPending;

    private Timer updateTimer;
    private TimerTask updateTimerTask;
    private Timer transTimer;
    private TimerTask transTimerTask;

    private int timeToNextUpdateMs;
    private int txErrors;
    private int txRetries;

    /**
     * Private constants
     */
    private static final int REQ_TIMEOUT_MS = 250;
    private static final int MAX_RETRIES = 2;
    private static final int MAX_UPDATE_PERIOD_MS = 1000;
    private static final int MIN_UPDATE_PERIOD_MS = 1;
    private static final int MAX_QUEUE_SIZE = 20;



}
