/**
 ******************************************************************************
 * @addtogroup OpenPilotModules OpenPilot Modules
 * @{
 * @addtogroup ET_EGT_Sensor EagleTree EGT Sensor Module
 * @brief Read ET EGT temperature sensors @ref ETEGTSensor "ETEGTSensor UAV Object"
 * @{
 *
 * @file       et_egt_sensor.c
 * @author     The OpenPilot Team, http://www.openpilot.org Copyright (C) 2010.
 * @brief      Reads dual thermocouple temperature sensors via EagleTree EGT expander
 *
 * @see        The GNU Public License (GPL) Version 3
 *
 *****************************************************************************/
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

/**
 * Output object: GasEngine
 *
 * This module will periodically update the value of the GasEngine UAVobject.
 *
 */

#include "openpilot.h"
#include "gasengine.h"
#include "mcp3424.h"
#include "gasengine.h"	// UAVobject that will be updated by the module
#include "gasenginesettings.h" // UAVobject used to modify module settings
#include "pios_i2c.h"

// Private constants
#define STACK_SIZE_BYTES 600
#define TASK_PRIORITY (tskIDLE_PRIORITY+1)
#define UPDATE_PERIOD 500
static double_t vPerC = 0.0000403; //volts per celcius for K-type thermocouple

// Private types
#define MCP9804_I2C_ADDRESS 0x1F //Cold junction temperature sensor
#define GASENGINE_I2C_ADDRESS 0x68 //Four channel ADC sensor MCP3424

// Private variables
static xTaskHandle taskHandle;

// down sampling variables
//#define MCP3424_ds_size    4
//static int32_t MCP3424_ds_temp1 = 0;
//static int32_t MCP3424_ds_temp2 = 0;
//static int MCP3424_ds_count = 0;

// Private functions
static void GasEngineTask(void *parameters);

/**
* Start the module, called on startup
*/
int32_t GasEngineStart()
{
	// Start main task
	xTaskCreate(GasEngineTask, (signed char *)"GasEngine", STACK_SIZE_BYTES/4, NULL, TASK_PRIORITY, &taskHandle);
	TaskMonitorAdd(TASKINFO_RUNNING_GasEngine, taskHandle);
	return 0;
}

/**
* Initialise the module, called on startup
*/
int32_t GasEngineInitialize()
{
	GasEngineInitialize(); //Initialise the UAVObject used for transferring data to GCS
	GasEngineSettingsInitialize();

	// init down-sampling data
//	MCP3424_ds_temp1 = 0;
//	MCP3424_ds_temp2 = 0;
//	MCP3424_ds_count = 0;

	return 0;
}

MODULE_INITCALL(GasEngineInitialize, GasEngineStart)


/*
 * Read CylinderHeadTemp using a K-type thermocouple connected to Channel 1 of the MCP3424 IC
 * on the I2C bus
 */

static bool ReadCylinderHeadTemp(uint8_t* pI2CAddress, uint8_t* pBuffer, double_t* pTemperature, uint8_t* pConfigByte)
{
	uint8_t channel = 1;
	uint8_t numDataBytes = 3;
	uint8_t resolution, gain = 0;
	uint32_t counts = 0;

	bool success = MCP3424_SetConfig(pI2CAddress, channel, &numDataBytes, &resolution, &gain, pConfigByte);

	if(!success)
		return false;

	//wait long enough for conversion to happen after setting config
	vTaskDelay(MCP3424_GetDelay(&resolution) / portTICK_RATE_MS);

	if (MCP3424_GetAnalogCounts(pI2CAddress, pBuffer, &numDataBytes, &resolution, &counts))
	{
		//Assume K-type thermocouple is connected to channel 1
		//do conversion here
		double_t LSB = 2 * MCP3424_REFVOLTAGE / (1 << resolution);
		*pTemperature = (int32_t)counts * LSB / vPerC / gain;

		return true;
	}
	else
		return false;
}

/*
 * Read Exhaust Gas Temp using a K-type thermocouple connected to Channel 2 of the MCP3424 IC
 * on the I2C bus
 */

static bool ReadExhaustGasTemp(uint8_t* pI2CAddress, uint8_t* pBuffer, double_t* pTemperature, uint8_t* pConfigByte)
{
	uint8_t channel = 2;
	uint8_t numDataBytes = 3;
	uint8_t bufferTemp[4] = {0};  //buffer to store return data from sensor
	uint8_t resolution, gain = 0;
	uint32_t counts = 0;

	bool success = MCP3424_SetConfig(pI2CAddress, channel, &numDataBytes, &resolution, &gain, pConfigByte);

	if(!success)
		return false;

	//wait long enough for conversion to happen after setting config
	vTaskDelay(MCP3424_GetDelay(&resolution) / portTICK_RATE_MS);

	const struct pios_i2c_txn txn_list_1[] = {
		{
		 .addr = *pI2CAddress,
		 .rw = PIOS_I2C_TXN_READ,
		 .len = 4, //Upper, Middle, Lower data bytes and config byte returned for 18 bit mode
		 .buf = bufferTemp,
		 },
	};

	//Read data bytes
	if(PIOS_I2C_Transfer(PIOS_I2C_MAIN_ADAPTER, txn_list_1, NELEMENTS(txn_list_1))) {

		decipherI2Cresponse(bufferTemp, pBuffer, &numDataBytes, &resolution, &counts);

		//Assume K-type thermocouple is connected to channel 1
		//do conversion here
		double_t LSB = 2 * MCP3424_REFVOLTAGE / (1 << resolution);
		*pTemperature = (int32_t)counts * LSB / vPerC / gain;

		return true;
	}
	else
		return false;
}

/*
 * Read the ignition battery voltage via the AttoPilot voltage and current sensor board connected to Channel 3
 * of the MCP3424 IC on the I2C bus
 */
static bool ReadIgnitionBatteryVoltage(uint8_t* pI2CAddress, uint8_t* pBuffer, double_t* pVoltage, uint8_t* pConfigByte, uint32_t* pRawCounts)
{
	uint8_t channel = 3;
	uint8_t numDataBytes = 3;
	uint8_t bufferTemp[4] = {0};  //buffer to store return data from sensor
	uint8_t resolution, gain = 0;
	uint32_t counts = 0;

	bool success = MCP3424SetConfig(pI2CAddress, channel, &numDataBytes, &resolution, &gain, pConfigByte);

	if(!success)
		return false;

	//wait long enough for conversion to happen after setting config
	vTaskDelay(GetDelay(&resolution) / portTICK_RATE_MS);

	const struct pios_i2c_txn txn_list_1[] = {
		{
		 .addr = *pI2CAddress,
		 .rw = PIOS_I2C_TXN_READ,
		 .len = 4, //Upper, Middle, Lower data bytes and config byte returned for 18 bit mode
		 .buf = bufferTemp,
		 },
	};

	//Read data bytes
	if(PIOS_I2C_Transfer(PIOS_I2C_MAIN_ADAPTER, txn_list_1, NELEMENTS(txn_list_1))) {

		decipherI2Cresponse(bufferTemp, pBuffer, &numDataBytes, &resolution, &counts);

		pBuffer[6] = gain;

		//Assume Attopilot voltage and current sensor is being used.
		// Specifically, the full scale voltage is 51.8V = 3.3V
		// Full scale current is 90A = 3.3V
		double_t attoPilotVscale = 1 / 0.06369; //From data sheet

		double_t LSB = 2 * MCP3424_REFVOLTAGE / (1 << resolution);
		*pVoltage = (int32_t)counts * LSB / gain * attoPilotVscale;

		*pRawCounts = counts;

		return true;
	}
	else
		return false;
}

/*
 * Read the ignition battery current via the AttoPilot voltage and current sensor board connected to Channel 4
 * of the MCP3424 IC on the I2C bus
 */
static bool ReadIgnitionBatteryCurrent(uint8_t* pI2CAddress, uint8_t* pBuffer, double_t* pCurrent, uint8_t* pConfigByte)
{
	uint8_t channel = 4;
	uint8_t numDataBytes = 3;
	uint8_t bufferTemp[4] = {0};  //buffer to store return data from sensor
	uint8_t resolution, gain = 0;
	uint32_t counts = 0;

	bool success = MCP3424SetConfig(pI2CAddress, channel, &numDataBytes, &resolution, &gain, pConfigByte);

	if(!success)
		return false;

	//wait long enough for conversion to happen after setting config
	vTaskDelay(GetDelay(&resolution) / portTICK_RATE_MS);

	const struct pios_i2c_txn txn_list_1[] = {
		{
		 .addr = *pI2CAddress,
		 .rw = PIOS_I2C_TXN_READ,
		 .len = 4, //Upper, Middle, Lower data bytes and config byte returned for 18 bit mode
		 .buf = bufferTemp,
		 },
	};

	//Read data bytes
	if(PIOS_I2C_Transfer(PIOS_I2C_MAIN_ADAPTER, txn_list_1, NELEMENTS(txn_list_1))) {

		decipherI2Cresponse(bufferTemp, pBuffer, &numDataBytes, &resolution, &counts);

		//Assume 90A Attopilot voltage and current sensor is being used.
		// Full scale current is 90A = 3.3V
		double_t attoPilotIscale = 1 / 0.0366; //From data sheet

		double_t LSB = 2 * MCP3424_REFVOLTAGE / (1 << resolution);
		*pCurrent = (int32_t)counts * LSB / gain * attoPilotIscale;

		return true;
	}
	else
		return false;
}


/**
 * Module thread, should not return.
 * Channel1 = cylinderHeadTemperature
 * Channel2 = exhaustGasTemperature
 * Channel3 = ignitionBatteryVoltage
 * Channel4 = ignitionBatteryAmps
 */
static void GasEngineTask(void *parameters)
{
	bool bParamSet = false;

	uint8_t buf[8] = {0};
	uint8_t configByte = 0;
	uint32_t rawCounts = 0;

	portTickType lastSysTime;

	//UAVObject data structure
	GasEngineData d1;

	double_t cylinderHeadTemp = 0;
	double_t exhaustGasTemp = 0;
	double_t batteryVoltage = 0;
	double_t batteryCurrent = 0;

	//down sample variables
//	double_t chan1_ds_size = 3;
//	double_t chan1_ds_temp = 0;
//	double_t chan1_ds_count = 0;

	double_t coldTemp = 0;

	portTickType energyTimeTickCount = 0; //delta time for calculating battery energy consumption

	bool bGasEngineRreadSuccess = false;

	// Main task loop
	lastSysTime = xTaskGetTickCount();

	while(1) {

		/*
		 * Read cold junction temp from separate MCP9804 IC via I2C
		 */
		bool b2 = Read_Cold_Junction_Temp(&coldTemp);

		/*
		 * Read channel 1
		 */
		bGasEngineRreadSuccess = ReadCylinderHeadTemp(buf, &cylinderHeadTemp, &configByte);

		if(bGasEngineRreadSuccess && b2) {
			//PIOS_LED_Off(LED2);

			//down sample
//			chan1_ds_temp += channel1;
//			if (++chan1_ds_count >= chan1_ds_size)
//			{
//				chan1_ds_count = 0;
//
//				// Get average of last 10 samples
//				channel1 = chan1_ds_temp / chan1_ds_size;
//				chan1_ds_temp = 0;
//			}

			cylinderHeadTemp += coldTemp; //thermocouple reads temperature relative to cold junction

			d1.CylinderHeadTemp = cylinderHeadTemp; //calculated temperature
			d1.ColdJunction = coldTemp;
		}
		else {
			//PIOS_LED_On(LED2);
			d1.buf0 = 99;
			d1.buf1 = 99;
			d1.buf2 = 99;
			d1.buf4 = 111;

			//configuration may be wrong so set flag to set parameters again
			bParamSet = false;
		}

		/*
		 * Read channel 2
		 */
		//Read thermocouple connected to channel 1 of MCP3424 IC via I2C
		ReadExhaustGasTemp(buf, &exhaustGasTemp, &configByte);
		exhaustGasTemp += coldTemp; //thermocouple reads temperature relative to cold junction
		d1.ExhaustGasTemp = exhaustGasTemp;

		/*
		 * Read channel 3
		 */
		ReadIgnitionBatteryVoltage(buf, &batteryVoltage, &configByte, &rawCounts);
		d1.BatteryVoltage = batteryVoltage;
//		d1.buf0 = buf[0]; //data1
//		d1.buf1 = buf[1]; //data2
//		d1.buf2 = buf[2]; //data3
//		d1.buf3 = buf[3]; //data4
		//d1.CylinderHeadTemp = cylinderHeadTemp; //calculated temperature
		//d1.ColdJunction = coldTemp;
//		d1.buf4 = buf[4]; //raw counts
//		d1.buf5 = buf[5];
//		d1.buf6 = buf[6];
//		d1.buf6 = configByte;
//		d1.buf7 = rawCounts;

		/*
		 * Read channel 4
		 */
		ReadIgnitionBatteryCurrent(buf, &batteryCurrent, &configByte);
		d1.BatteryAmps = batteryCurrent;

		portTickType x = xTaskGetTickCount();
		portTickType deltaT = (x - energyTimeTickCount) * portTICK_RATE_MS; //Conversion to milliseconds
		energyTimeTickCount = x;

		float_t mAh = 0.0;
		GasEngineIgnitionBattery_mAhGet(&mAh); //This allows some other module or the GCS to reset it to zero

		d1.IgnitionBattery_mAh = mAh + (deltaT * batteryCurrent / 3600.0); //Conversion to mAh

		/*
		 * Update UAVObject data
		 */
		GasEngineSet(&d1);

		// Delay until it is time to read the next sample
		vTaskDelayUntil(&lastSysTime, UPDATE_PERIOD / portTICK_RATE_MS);
	}
}



/**
  * @}
 * @}
 */
