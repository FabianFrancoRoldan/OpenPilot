#ifndef TELEMETRY_H
#define TELEMETRY_H

#include "signals/Signals"
#include "OPTypes"
#include "OPVector"
#include "OPMap"
#include "thread/CMutex"
#include "system/CTime"
#include "gcstelemetrystats.h"

class UAVTalk;
class UAVObjectManager;
class UAVObject;

class Telemetry;

class ObjectTransactionInfo
{
public:
    ObjectTransactionInfo();
    ~ObjectTransactionInfo();

    void start(int waitTime);
    void stop();
    void onUpdate();

    UAVObject   * obj;
    bool          allInstances;
    bool          objRequest;
    opint32       retriesRemaining;
    bool          acked;
    Telemetry   * telem;
    CTime         m_startTime;
    int           m_waitTime;
    bool          m_bStarted;

private:
    void timeout();
};

class Telemetry
{
private:
    // Constants
    static const int REQ_TIMEOUT_MS = 250;
    static const int MAX_RETRIES = 2;
    static const int MAX_UPDATE_PERIOD_MS = 1000;
    static const int MIN_UPDATE_PERIOD_MS = 1;
    static const int MAX_QUEUE_SIZE = 20;

// Types
    /**
     * Events generated by objects
     */
    enum EventMask {
        EV_NONE = 0x00, /** No event */
        EV_UNPACKED = 0x01, /** Object data updated by unpacking */
        EV_UPDATED = 0x02, /** Object data updated by changing the data structure */
        EV_UPDATED_MANUAL = 0x04, /** Object update event manually generated */
        EV_UPDATED_PERIODIC = 0x8, /** Object update event generated by timer */
        EV_UPDATE_REQ = 0x010 /** Request to update object data */
    };

    typedef struct {
        UAVObject* obj;
        opint32 updatePeriodMs; /** Update period in ms or 0 if no periodic updates are needed */
        opint32 timeToNextUpdateMs; /** Time delay to the next update */
    } ObjectTimeInfo;

    typedef struct {
        UAVObject* obj;
        EventMask event;
        bool      allInstances;
    } ObjectQueueInfo;

    typedef struct tagObjectConnect
    {
        UAVObject * obj;
        CL_Slot     slotObjectUnpacked;
        CL_Slot     slotUpdatedAuto;
        CL_Slot     slotUpdatedManual;
        CL_Slot     slotUpdatedPeriodic;
        CL_Slot     slotUpdateRequest;

    } OBJECTCONNECT, *POBJECTCONNECT;

public:
    typedef struct tagStats
    {
        opuint32 txBytes;
        opuint32 rxBytes;
        opuint32 txObjectBytes;
        opuint32 rxObjectBytes;
        opuint32 rxObjects;
        opuint32 txObjects;
        opuint32 txErrors;
        opuint32 rxErrors;
        opuint32 txRetries;
    } TelemetryStats;

public:
    Telemetry(UAVTalk* talk, UAVObjectManager* manager);
    ~Telemetry();

    TelemetryStats getStats() const;
    void resetStats();

// notifies
    void onUpdate(float timeElapsed);
    void transactionTimeout(ObjectTransactionInfo *info);

private:
    UAVTalk                          * m_talk;
    UAVObjectManager                 * m_manager;
    GCSTelemetryStats                * m_gcsStatsObj;
    opvector<ObjectTimeInfo>           m_objList;
    oplist<ObjectQueueInfo>            m_objQueue;
    oplist<ObjectQueueInfo>            m_objPriorityQueue;
    opmap<UAVObject*, OBJECTCONNECT>   m_connectedObjs;
    opmap<opuint32, ObjectTransactionInfo*> m_transMap;
    bool m_bTransMapChanged;

    bool   m_timerStarted;
    CTime  m_startTime;
    int    m_waitTime;
    int    m_timeToNextUpdateMs;
    int    m_txErrors;
    int    m_txRetries;
    mutable CMutex m_mutex;

    CL_Slot m_slotNewObject;
    CL_Slot m_slotNewInstance;
    CL_Slot m_slotTransactionCompleted;

    void registerObject(UAVObject* obj);
    void addObject(UAVObject* obj);
    void updateObject(UAVObject* obj, opuint32 eventType);
    void setUpdatePeriod(UAVObject* obj, opint32 periodMs);
    void connectToObjectInstances(UAVObject* obj, opuint32 eventMask);
    void processPeriodicUpdates();
    void processObjectUpdates(UAVObject* obj, EventMask event, bool allInstances, bool priority);
    void processObjectQueue();
    void processObjectTransaction(ObjectTransactionInfo *transInfo);

// slots
    void objectUnpacked(UAVObject* object);
    void objectUpdatedAuto(UAVObject* object);
    void objectUpdatedManual(UAVObject* object);
    void objectUpdatedPeriodic(UAVObject* object);
    void updateRequested(UAVObject* object);
    void newObject(UAVObject* object);
    void newInstance(UAVObject* object);
    void transactionCompleted(UAVObject* object, bool sucess);
};

#endif // TELEMETRY_H
